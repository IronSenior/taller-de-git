{
    "docs": [
        {
            "location": "/", 
            "text": "Taller de introducci\u00f3n a Git\n\n\n\n\nEste taller forma parte de las actividades del \nAula de Software Libre de la\nUniversidad de C\u00f3rdoba\n.\n\n\nEl contenido del mismo es en parte de producci\u00f3n propia, en parte de otros\nmanuales libres que pueden encontrarse en la secci\u00f3n de \nReferencias\n.\n\n\nContenido\n\n\n\n\nInicio\n\n\nSistemas de control de versiones\n\n\nIntroducci\u00f3n a Git\n\n\nAspectos b\u00e1sicos de Git\n\n\nUso b\u00e1sico\n\n\nUso avanzado\n\n\nRamas\n\n\nAdministraci\u00f3n de repositorios\n\n\nFlujo de trabajo con Git (git flow)\n\n\nGithub\n\n\nReferencias\n\n\n\n\nAgradecimientos\n\n\nEste curso ha sido impartido por las siguientes personas:\n\n\n\n\nH\u00e9ctor Romero\n\n\nJos\u00e9 M\u00e1rquez\n\n\nSergio G\u00f3mez", 
            "title": "Inicio"
        }, 
        {
            "location": "/#taller-de-introduccion-a-git", 
            "text": "Este taller forma parte de las actividades del  Aula de Software Libre de la\nUniversidad de C\u00f3rdoba .  El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros\nmanuales libres que pueden encontrarse en la secci\u00f3n de  Referencias .", 
            "title": "Taller de introducci\u00f3n a Git"
        }, 
        {
            "location": "/#contenido", 
            "text": "Inicio  Sistemas de control de versiones  Introducci\u00f3n a Git  Aspectos b\u00e1sicos de Git  Uso b\u00e1sico  Uso avanzado  Ramas  Administraci\u00f3n de repositorios  Flujo de trabajo con Git (git flow)  Github  Referencias", 
            "title": "Contenido"
        }, 
        {
            "location": "/#agradecimientos", 
            "text": "Este curso ha sido impartido por las siguientes personas:   H\u00e9ctor Romero  Jos\u00e9 M\u00e1rquez  Sergio G\u00f3mez", 
            "title": "Agradecimientos"
        }, 
        {
            "location": "/cvs/", 
            "text": "Sistemas de control de versiones\n\n\nDefinici\u00f3n, clasificaci\u00f3n y funcionamiento\n\n\nSe llama control de versiones a la gesti\u00f3n de los diversos cambios que se realizan sobre los elementos de alg\u00fan producto o una configuraci\u00f3n del mismo. Una versi\u00f3n, revisi\u00f3n o edici\u00f3n de un producto, es el estado en el que se encuentra dicho producto en un momento dado de su desarrollo o modificaci\u00f3n. Aunque un sistema de control de versiones puede realizarse de forma manual, es muy aconsejable disponer de herramientas que faciliten esta gesti\u00f3n dando lugar a los llamados sistemas de control de versiones o SVC (del ingl\u00e9s System Version Control).\n\n\nEstos sistemas facilitan la administraci\u00f3n de las distintas versiones de cada producto desarrollado, as\u00ed como las posibles especializaciones realizadas (por ejemplo, para alg\u00fan cliente espec\u00edfico). Ejemplos de este tipo de herramientas son entre otros: CVS, Subversion, SourceSafe, ClearCase, Darcs, Bazaar , Plastic SCM, Git, Mercurial, Perforce.\n\n\nTerminolog\u00eda\n\n\n\n\nRepositorio (\"repository\")\n\n\nEl repositorio es el lugar en el que se almacenan los datos actualizados e hist\u00f3ricos de cambios.\n\n\nRevisi\u00f3n (\"revision\")\n\n\nUna revisi\u00f3n es una versi\u00f3n determinada de la informaci\u00f3n que se gestiona. Hay sistemas que identifican las revisiones con un contador (Ej. subversion). Hay otros sistemas que identifican las revisiones mediante un c\u00f3digo de detecci\u00f3n de modificaciones (Ej. git usa SHA1).\n\n\nEtiqueta (\"tag\")\n\n\nLos tags permiten identificar de forma f\u00e1cil revisiones importantes en el proyecto. Por ejemplo se suelen usar tags para identificar el contenido de las versiones publicadas del proyecto.\n\n\nRama (\"branch\")\n\n\nUn conjunto de archivos puede ser ramificado o bifurcado en un punto en el tiempo de manera que, a partir de ese momento, dos copias de esos archivos se pueden desarrollar a velocidades diferentes o en formas diferentes de forma independiente el uno del otro.\n\n\nCambio (\"change\")\n\n\nUn cambio (o diff, o delta) representa una modificaci\u00f3n espec\u00edfica de un documento bajo el control de versiones. La granularidad de la modificaci\u00f3n que es considerada como un cambio var\u00eda entre los sistemas de control de versiones.\n\n\nDesplegar (\"checkout\")\n\n\nEs crear una copia de trabajo local desde el repositorio. Un usuario puede especificar una revisi\u00f3n en concreto u obtener la \u00faltima. El t\u00e9rmino 'checkout' tambi\u00e9n se puede utilizar como un sustantivo para describir la copia de trabajo.\n\n\nConfirmar (\"commit\")\n\n\nConfirmar es escribir o mezclar los cambios realizados en la copia de trabajo del repositorio. Los t\u00e9rminos 'commit' y 'checkin' tambi\u00e9n se pueden utilizar como sustantivos para describir la nueva revisi\u00f3n que se crea como resultado de confirmar.\n\n\nConflicto (\"conflict\")\n\n\nUn conflicto se produce cuando diferentes partes realizan cambios en el mismo documento, y el sistema es incapaz de conciliar los cambios. Un usuario debe resolver el conflicto mediante la integraci\u00f3n de los cambios, o mediante la selecci\u00f3n de un cambio en favor del otro.\n\n\nCabeza (\"head\")\n\n\nTambi\u00e9n a veces se llama tip (punta) y se refiere a la \u00faltima confirmaci\u00f3n, ya sea en el tronco ('trunk') o en una rama ('branch'). El tronco y cada rama tienen su propia cabeza, aunque HEAD se utiliza a veces libremente para referirse al tronco.\n\n\nTronco (\"trunk\")\n\n\nLa \u00fanica l\u00ednea de desarrollo que no es una rama (a veces tambi\u00e9n llamada l\u00ednea base, l\u00ednea principal o m\u00e1ster).\n\n\nFusionar, integrar, mezclar (\"merge\")\n\n\nUna fusi\u00f3n o integraci\u00f3n es una operaci\u00f3n en la que se aplican dos tipos de cambios en un archivo o conjunto de archivos. Algunos escenarios de ejemplo son los siguientes:\n\n\n\n\n\n\nUn usuario, trabajando en un conjunto de archivos, actualiza o sincroniza su copia de trabajo con los cambios realizados y confirmados, por otros usuarios, en el repositorio.\n\n\nUn usuario intenta confirmar archivos que han sido actualizado por otros usuarios desde el \u00faltimo despliegue ('checkout'), y el software de control de versiones integra autom\u00e1ticamente los archivos (por lo general, despu\u00e9s de preguntarle al usuario si se debe proceder con la integraci\u00f3n autom\u00e1tica, y en algunos casos s\u00f3lo se hace si la fusi\u00f3n puede ser clara y razonablemente resuelta).\n\n\nUn conjunto de archivos se bifurca, un problema que exist\u00eda antes de la ramificaci\u00f3n se trabaja en una nueva rama, y la soluci\u00f3n se combina luego en la otra rama.\n\n\nSe crea una rama, el c\u00f3digo de los archivos es independiente editado, y la rama actualizada se incorpora m\u00e1s tarde en un \u00fanico tronco unificado.\n\n\n\n\nClasificaci\u00f3n\n\n\nPodemos clasificar los sistemas de control de versiones atendiendo a la arquitectura utilizada para el almacenamiento del c\u00f3digo: locales, centralizados y distribuidos.\n\n\nLocales\n\n\n\n\nLos cambios son guardados localmente y no se comparten con nadie. Esta arquitectura es la antecesora de las dos siguientes.\n\n\n\n\n\n\nCentralizados\n\n\nExiste un repositorio centralizado de todo el c\u00f3digo, del cual es responsable un \u00fanico usuario (o conjunto de ellos). Se facilitan las tareas administrativas a cambio de reducir flexibilidad, pues todas las decisiones fuertes (como crear una nueva rama) necesitan la aprobaci\u00f3n del responsable. Algunos ejemplos son CVS y Subversion.\n\n\n\n\nDistribuidos\n\n\nCada usuario tiene su propio repositorio. Los distintos repositorios pueden intercambiar y mezclar revisiones entre ellos. Es frecuente el uso de un repositorio, que est\u00e1 normalmente disponible, que sirve de punto de sincronizaci\u00f3n de los distintos repositorios locales. Ejemplos: Git y Mercurial.\n\n\n\n\nVentajas de sistemas distribuidos\n\n\n\n\nNo es necesario estar conectado para guardar cambios.\n\n\nPosibilidad de continuar trabajando si el repositorio remoto no est\u00e1 accesible.\n\n\nEl repositorio central est\u00e1 m\u00e1s libre de ramas de pruebas.\n\n\nSe necesitan menos recursos para el repositorio remoto.\n\n\nM\u00e1s flexibles al permitir gestionar cada repositorio personal como se quiera.", 
            "title": "Sistemas de control de versiones"
        }, 
        {
            "location": "/cvs/#sistemas-de-control-de-versiones", 
            "text": "", 
            "title": "Sistemas de control de versiones"
        }, 
        {
            "location": "/cvs/#definicion-clasificacion-y-funcionamiento", 
            "text": "Se llama control de versiones a la gesti\u00f3n de los diversos cambios que se realizan sobre los elementos de alg\u00fan producto o una configuraci\u00f3n del mismo. Una versi\u00f3n, revisi\u00f3n o edici\u00f3n de un producto, es el estado en el que se encuentra dicho producto en un momento dado de su desarrollo o modificaci\u00f3n. Aunque un sistema de control de versiones puede realizarse de forma manual, es muy aconsejable disponer de herramientas que faciliten esta gesti\u00f3n dando lugar a los llamados sistemas de control de versiones o SVC (del ingl\u00e9s System Version Control).  Estos sistemas facilitan la administraci\u00f3n de las distintas versiones de cada producto desarrollado, as\u00ed como las posibles especializaciones realizadas (por ejemplo, para alg\u00fan cliente espec\u00edfico). Ejemplos de este tipo de herramientas son entre otros: CVS, Subversion, SourceSafe, ClearCase, Darcs, Bazaar , Plastic SCM, Git, Mercurial, Perforce.", 
            "title": "Definici\u00f3n, clasificaci\u00f3n y funcionamiento"
        }, 
        {
            "location": "/cvs/#terminologia", 
            "text": "Repositorio (\"repository\")  El repositorio es el lugar en el que se almacenan los datos actualizados e hist\u00f3ricos de cambios.  Revisi\u00f3n (\"revision\")  Una revisi\u00f3n es una versi\u00f3n determinada de la informaci\u00f3n que se gestiona. Hay sistemas que identifican las revisiones con un contador (Ej. subversion). Hay otros sistemas que identifican las revisiones mediante un c\u00f3digo de detecci\u00f3n de modificaciones (Ej. git usa SHA1).  Etiqueta (\"tag\")  Los tags permiten identificar de forma f\u00e1cil revisiones importantes en el proyecto. Por ejemplo se suelen usar tags para identificar el contenido de las versiones publicadas del proyecto.  Rama (\"branch\")  Un conjunto de archivos puede ser ramificado o bifurcado en un punto en el tiempo de manera que, a partir de ese momento, dos copias de esos archivos se pueden desarrollar a velocidades diferentes o en formas diferentes de forma independiente el uno del otro.  Cambio (\"change\")  Un cambio (o diff, o delta) representa una modificaci\u00f3n espec\u00edfica de un documento bajo el control de versiones. La granularidad de la modificaci\u00f3n que es considerada como un cambio var\u00eda entre los sistemas de control de versiones.  Desplegar (\"checkout\")  Es crear una copia de trabajo local desde el repositorio. Un usuario puede especificar una revisi\u00f3n en concreto u obtener la \u00faltima. El t\u00e9rmino 'checkout' tambi\u00e9n se puede utilizar como un sustantivo para describir la copia de trabajo.  Confirmar (\"commit\")  Confirmar es escribir o mezclar los cambios realizados en la copia de trabajo del repositorio. Los t\u00e9rminos 'commit' y 'checkin' tambi\u00e9n se pueden utilizar como sustantivos para describir la nueva revisi\u00f3n que se crea como resultado de confirmar.  Conflicto (\"conflict\")  Un conflicto se produce cuando diferentes partes realizan cambios en el mismo documento, y el sistema es incapaz de conciliar los cambios. Un usuario debe resolver el conflicto mediante la integraci\u00f3n de los cambios, o mediante la selecci\u00f3n de un cambio en favor del otro.  Cabeza (\"head\")  Tambi\u00e9n a veces se llama tip (punta) y se refiere a la \u00faltima confirmaci\u00f3n, ya sea en el tronco ('trunk') o en una rama ('branch'). El tronco y cada rama tienen su propia cabeza, aunque HEAD se utiliza a veces libremente para referirse al tronco.  Tronco (\"trunk\")  La \u00fanica l\u00ednea de desarrollo que no es una rama (a veces tambi\u00e9n llamada l\u00ednea base, l\u00ednea principal o m\u00e1ster).  Fusionar, integrar, mezclar (\"merge\")  Una fusi\u00f3n o integraci\u00f3n es una operaci\u00f3n en la que se aplican dos tipos de cambios en un archivo o conjunto de archivos. Algunos escenarios de ejemplo son los siguientes:    Un usuario, trabajando en un conjunto de archivos, actualiza o sincroniza su copia de trabajo con los cambios realizados y confirmados, por otros usuarios, en el repositorio.  Un usuario intenta confirmar archivos que han sido actualizado por otros usuarios desde el \u00faltimo despliegue ('checkout'), y el software de control de versiones integra autom\u00e1ticamente los archivos (por lo general, despu\u00e9s de preguntarle al usuario si se debe proceder con la integraci\u00f3n autom\u00e1tica, y en algunos casos s\u00f3lo se hace si la fusi\u00f3n puede ser clara y razonablemente resuelta).  Un conjunto de archivos se bifurca, un problema que exist\u00eda antes de la ramificaci\u00f3n se trabaja en una nueva rama, y la soluci\u00f3n se combina luego en la otra rama.  Se crea una rama, el c\u00f3digo de los archivos es independiente editado, y la rama actualizada se incorpora m\u00e1s tarde en un \u00fanico tronco unificado.", 
            "title": "Terminolog\u00eda"
        }, 
        {
            "location": "/cvs/#clasificacion", 
            "text": "Podemos clasificar los sistemas de control de versiones atendiendo a la arquitectura utilizada para el almacenamiento del c\u00f3digo: locales, centralizados y distribuidos.", 
            "title": "Clasificaci\u00f3n"
        }, 
        {
            "location": "/cvs/#locales", 
            "text": "Los cambios son guardados localmente y no se comparten con nadie. Esta arquitectura es la antecesora de las dos siguientes.", 
            "title": "Locales"
        }, 
        {
            "location": "/cvs/#centralizados", 
            "text": "Existe un repositorio centralizado de todo el c\u00f3digo, del cual es responsable un \u00fanico usuario (o conjunto de ellos). Se facilitan las tareas administrativas a cambio de reducir flexibilidad, pues todas las decisiones fuertes (como crear una nueva rama) necesitan la aprobaci\u00f3n del responsable. Algunos ejemplos son CVS y Subversion.", 
            "title": "Centralizados"
        }, 
        {
            "location": "/cvs/#distribuidos", 
            "text": "Cada usuario tiene su propio repositorio. Los distintos repositorios pueden intercambiar y mezclar revisiones entre ellos. Es frecuente el uso de un repositorio, que est\u00e1 normalmente disponible, que sirve de punto de sincronizaci\u00f3n de los distintos repositorios locales. Ejemplos: Git y Mercurial.", 
            "title": "Distribuidos"
        }, 
        {
            "location": "/cvs/#ventajas-de-sistemas-distribuidos", 
            "text": "No es necesario estar conectado para guardar cambios.  Posibilidad de continuar trabajando si el repositorio remoto no est\u00e1 accesible.  El repositorio central est\u00e1 m\u00e1s libre de ramas de pruebas.  Se necesitan menos recursos para el repositorio remoto.  M\u00e1s flexibles al permitir gestionar cada repositorio personal como se quiera.", 
            "title": "Ventajas de sistemas distribuidos"
        }, 
        {
            "location": "/introduccion/", 
            "text": "Introducci\u00f3n a git\n\n\nGit es un sistema de control de versiones distribuido que se diferencia del resto en el modo en que modela sus datos. La mayor\u00eda de los dem\u00e1s sistemas almacenan la informaci\u00f3n como una lista de cambios en los archivos, mientras que Git modela sus datos m\u00e1s como un conjunto de instant\u00e1neas de un mini sistema de archivos.\n\n\n\n\n\n\nLos tres estados\n\n\nGit tiene tres estados principales en los que se pueden encontrar tus archivos: confirmado (committed), modificado (modified), y preparado (staged). Confirmado significa que los datos est\u00e1n almacenados de manera segura en tu base de datos local. Modificado significa que has modificado el archivo pero todav\u00eda no lo has confirmado a tu base de datos. Preparado significa que has marcado un archivo modificado en su versi\u00f3n actual para que vaya en tu pr\u00f3xima confirmaci\u00f3n.\n\n\nEsto nos lleva a las tres secciones principales de un proyecto de Git: el directorio de Git (Git directory), el directorio de trabajo (working directory), y el \u00e1rea de preparaci\u00f3n (staging area).\n\n\n\n\nFlujos de trabajo distribuidos con git\n\n\nHemos visto en qu\u00e9 consiste un entorno de control de versiones distribuido, pero m\u00e1s all\u00e1 de la simple definici\u00f3n, existe m\u00e1s de una manera de gestionar los repositorios. Estos son los flujos de trabajo m\u00e1s comunes en Git.\n\n\nFlujo de trabajo centralizado\n\n\nExiste un \u00fanico repositorio o punto central que guarda el c\u00f3digo y todo el mundo sincroniza su trabajo con \u00e9l. Si dos desarrolladores clonan desde el punto central, y ambos hacen cambios; tan solo el primero de ellos en enviar sus cambios de vuelta lo podr\u00e1 hacer limpiamente. El segundo desarrollador deber\u00e1 fusionar previamente su trabajo con el del primero, antes de enviarlo, para evitar el sobreescribir los cambios del primero\n\n\n\n\nFlujo de trabajo del Gestor-de-Integraciones\n\n\nAl permitir m\u00faltiples repositorios remotos, en Git es posible tener un flujo de trabajo donde cada desarrollador tenga acceso de escritura a su propio repositorio p\u00fablico y acceso de lectura a los repositorios de todos los dem\u00e1s. Habitualmente, este escenario suele incluir un repositorio can\u00f3nico, representante \"oficial\" del proyecto.\n\n\n\n\n\n\nInfo\n\n\nEste modelo se puso muy de moda a ra\u00edz de la forja GitHub que se ver\u00e1 m\u00e1s adelante.\n\n\n\n\nFlujo de trabajo con Dictador y Tenientes\n\n\nEs una variante del flujo de trabajo con m\u00faltiples repositorios. Se utiliza generalmente en proyectos muy grandes, con cientos de colaboradores. Un ejemplo muy conocido es el del kernel de Linux. Unos gestores de integraci\u00f3n se encargan de partes concretas del repositorio; y se denominan tenientes. Todos los tenientes rinden cuentas a un gestor de integraci\u00f3n; conocido como el dictador benevolente. El repositorio del dictador benevolente es el repositorio de referencia, del que recuperan (pull) todos los colaboradores.", 
            "title": "Introducci\u00f3n a Git"
        }, 
        {
            "location": "/introduccion/#introduccion-a-git", 
            "text": "Git es un sistema de control de versiones distribuido que se diferencia del resto en el modo en que modela sus datos. La mayor\u00eda de los dem\u00e1s sistemas almacenan la informaci\u00f3n como una lista de cambios en los archivos, mientras que Git modela sus datos m\u00e1s como un conjunto de instant\u00e1neas de un mini sistema de archivos.", 
            "title": "Introducci\u00f3n a git"
        }, 
        {
            "location": "/introduccion/#los-tres-estados", 
            "text": "Git tiene tres estados principales en los que se pueden encontrar tus archivos: confirmado (committed), modificado (modified), y preparado (staged). Confirmado significa que los datos est\u00e1n almacenados de manera segura en tu base de datos local. Modificado significa que has modificado el archivo pero todav\u00eda no lo has confirmado a tu base de datos. Preparado significa que has marcado un archivo modificado en su versi\u00f3n actual para que vaya en tu pr\u00f3xima confirmaci\u00f3n.  Esto nos lleva a las tres secciones principales de un proyecto de Git: el directorio de Git (Git directory), el directorio de trabajo (working directory), y el \u00e1rea de preparaci\u00f3n (staging area).", 
            "title": "Los tres estados"
        }, 
        {
            "location": "/introduccion/#flujos-de-trabajo-distribuidos-con-git", 
            "text": "Hemos visto en qu\u00e9 consiste un entorno de control de versiones distribuido, pero m\u00e1s all\u00e1 de la simple definici\u00f3n, existe m\u00e1s de una manera de gestionar los repositorios. Estos son los flujos de trabajo m\u00e1s comunes en Git.", 
            "title": "Flujos de trabajo distribuidos con git"
        }, 
        {
            "location": "/introduccion/#flujo-de-trabajo-centralizado", 
            "text": "Existe un \u00fanico repositorio o punto central que guarda el c\u00f3digo y todo el mundo sincroniza su trabajo con \u00e9l. Si dos desarrolladores clonan desde el punto central, y ambos hacen cambios; tan solo el primero de ellos en enviar sus cambios de vuelta lo podr\u00e1 hacer limpiamente. El segundo desarrollador deber\u00e1 fusionar previamente su trabajo con el del primero, antes de enviarlo, para evitar el sobreescribir los cambios del primero", 
            "title": "Flujo de trabajo centralizado"
        }, 
        {
            "location": "/introduccion/#flujo-de-trabajo-del-gestor-de-integraciones", 
            "text": "Al permitir m\u00faltiples repositorios remotos, en Git es posible tener un flujo de trabajo donde cada desarrollador tenga acceso de escritura a su propio repositorio p\u00fablico y acceso de lectura a los repositorios de todos los dem\u00e1s. Habitualmente, este escenario suele incluir un repositorio can\u00f3nico, representante \"oficial\" del proyecto.    Info  Este modelo se puso muy de moda a ra\u00edz de la forja GitHub que se ver\u00e1 m\u00e1s adelante.", 
            "title": "Flujo de trabajo del Gestor-de-Integraciones"
        }, 
        {
            "location": "/introduccion/#flujo-de-trabajo-con-dictador-y-tenientes", 
            "text": "Es una variante del flujo de trabajo con m\u00faltiples repositorios. Se utiliza generalmente en proyectos muy grandes, con cientos de colaboradores. Un ejemplo muy conocido es el del kernel de Linux. Unos gestores de integraci\u00f3n se encargan de partes concretas del repositorio; y se denominan tenientes. Todos los tenientes rinden cuentas a un gestor de integraci\u00f3n; conocido como el dictador benevolente. El repositorio del dictador benevolente es el repositorio de referencia, del que recuperan (pull) todos los colaboradores.", 
            "title": "Flujo de trabajo con Dictador y Tenientes"
        }, 
        {
            "location": "/git/", 
            "text": "Aspectos b\u00e1sicos de Git\n\n\nInstalaci\u00f3n\n\n\nInstalando en Linux\n\n\nSi quieres instalar Git en Linux a trav\u00e9s de un instalador binario, en general puedes hacerlo a trav\u00e9s de la herramienta b\u00e1sica de gesti\u00f3n de paquetes que trae tu distribuci\u00f3n. Si est\u00e1s en Fedora, puedes usar yum:\n\n\n$ yum install git-core\n\n\n\n\n\nO si est\u00e1s en una distribuci\u00f3n basada en Debian como Ubuntu, prueba con apt-get:\n\n\n$ apt-get install git\n\n\n\n\n\nInstalando en Windows\n\n\nInstalar Git en Windows es muy f\u00e1cil. El proyecto msysGit tiene uno de los procesos de instalaci\u00f3n m\u00e1s sencillos. Simplemente descarga el archivo exe del instalador desde la p\u00e1gina de GitHub, y ejec\u00fatalo:\n\n\nhttp://msysgit.github.com/\n\n\nUna vez instalado, tendr\u00e1s tanto la versi\u00f3n de l\u00ednea de comandos (incluido un cliente SSH que nos ser\u00e1 \u00fatil m\u00e1s adelante) como la interfaz gr\u00e1fica de usuario est\u00e1ndar. Se recomienda no modificar las opciones que trae por defecto el instalador.\n\n\nInstalando en MacOS\n\n\nEn MacOS se recomienda tener instalada la herramienta \nhomebrew\n. Despu\u00e9s, es tan f\u00e1cil como ejecutar:\n\n\n$ brew install git\n\n\n\n\n\nConfiguraci\u00f3n\n\n\nTu identidad\n\n\nLo primero que deber\u00edas hacer cuando instalas Git es establecer tu nombre de usuario y direcci\u00f3n de correo electr\u00f3nico. Esto es importante porque las confirmaciones de cambios (commits) en Git usan esta informaci\u00f3n, y es introducida de manera inmutable en los commits que env\u00edas:\n\n\n$ git config --global user.name \nJohn Doe\n\n$ git config --global user.email johndoe@example.com\n\n\n\n\n\nTambi\u00e9n se recomienda configurar el siguiente par\u00e1metro:\n\n\n$ git config --global push.default simple\n\n\n\n\n\nBash Completion\n\n\nBash completion\n es una utilidad que permite a bash completar \u00f3rdenes y par\u00e1metros. Por defecto suele venir desactivada en Ubuntu y es necesario modificar el archivo \n$HOME/.bashrc\n para poder activarla. Simplemente hay que descomentar las l\u00edneas que lo activan,\n\n\nTu clave p\u00fablica/privada\n\n\nMuchos servidores Git utilizan la autentificaci\u00f3n a trav\u00e9s de claves p\u00fablicas SSH. Y, para ello, cada usuario del sistema ha de generarse una, si es que no la tiene ya. El proceso para hacerlo es similar en casi cualquier sistema operativo. Ante todo, asegurarte que no tengas ya una clave. (comprueba que el directorio \n$HOME/usuario/.ssh\n no tiene un archivo id_dsa.pub o id_rsa.pub).\n\n\nPara crear una nueva clave usamos la siguiente orden:\n\n\n$ ssh-keygen -t rsa -C \nCuenta Thinstation\n\n\n\n\n\n\n\n\nWarning\n\n\nTu clave RSA te identifica contra los repositorios remotos, aseg\u00farate de\nno compartir la clave privada con nadie. Por defecto la clave se crea como\n\nsolo lectura\n.", 
            "title": "Aspectos b\u00e1sicos de Git"
        }, 
        {
            "location": "/git/#aspectos-basicos-de-git", 
            "text": "", 
            "title": "Aspectos b\u00e1sicos de Git"
        }, 
        {
            "location": "/git/#instalacion", 
            "text": "", 
            "title": "Instalaci\u00f3n"
        }, 
        {
            "location": "/git/#instalando-en-linux", 
            "text": "Si quieres instalar Git en Linux a trav\u00e9s de un instalador binario, en general puedes hacerlo a trav\u00e9s de la herramienta b\u00e1sica de gesti\u00f3n de paquetes que trae tu distribuci\u00f3n. Si est\u00e1s en Fedora, puedes usar yum:  $ yum install git-core  O si est\u00e1s en una distribuci\u00f3n basada en Debian como Ubuntu, prueba con apt-get:  $ apt-get install git", 
            "title": "Instalando en Linux"
        }, 
        {
            "location": "/git/#instalando-en-windows", 
            "text": "Instalar Git en Windows es muy f\u00e1cil. El proyecto msysGit tiene uno de los procesos de instalaci\u00f3n m\u00e1s sencillos. Simplemente descarga el archivo exe del instalador desde la p\u00e1gina de GitHub, y ejec\u00fatalo:  http://msysgit.github.com/  Una vez instalado, tendr\u00e1s tanto la versi\u00f3n de l\u00ednea de comandos (incluido un cliente SSH que nos ser\u00e1 \u00fatil m\u00e1s adelante) como la interfaz gr\u00e1fica de usuario est\u00e1ndar. Se recomienda no modificar las opciones que trae por defecto el instalador.", 
            "title": "Instalando en Windows"
        }, 
        {
            "location": "/git/#instalando-en-macos", 
            "text": "En MacOS se recomienda tener instalada la herramienta  homebrew . Despu\u00e9s, es tan f\u00e1cil como ejecutar:  $ brew install git", 
            "title": "Instalando en MacOS"
        }, 
        {
            "location": "/git/#configuracion", 
            "text": "", 
            "title": "Configuraci\u00f3n"
        }, 
        {
            "location": "/git/#tu-identidad", 
            "text": "Lo primero que deber\u00edas hacer cuando instalas Git es establecer tu nombre de usuario y direcci\u00f3n de correo electr\u00f3nico. Esto es importante porque las confirmaciones de cambios (commits) en Git usan esta informaci\u00f3n, y es introducida de manera inmutable en los commits que env\u00edas:  $ git config --global user.name  John Doe \n$ git config --global user.email johndoe@example.com  Tambi\u00e9n se recomienda configurar el siguiente par\u00e1metro:  $ git config --global push.default simple", 
            "title": "Tu identidad"
        }, 
        {
            "location": "/git/#bash-completion", 
            "text": "Bash completion  es una utilidad que permite a bash completar \u00f3rdenes y par\u00e1metros. Por defecto suele venir desactivada en Ubuntu y es necesario modificar el archivo  $HOME/.bashrc  para poder activarla. Simplemente hay que descomentar las l\u00edneas que lo activan,", 
            "title": "Bash Completion"
        }, 
        {
            "location": "/git/#tu-clave-publicaprivada", 
            "text": "Muchos servidores Git utilizan la autentificaci\u00f3n a trav\u00e9s de claves p\u00fablicas SSH. Y, para ello, cada usuario del sistema ha de generarse una, si es que no la tiene ya. El proceso para hacerlo es similar en casi cualquier sistema operativo. Ante todo, asegurarte que no tengas ya una clave. (comprueba que el directorio  $HOME/usuario/.ssh  no tiene un archivo id_dsa.pub o id_rsa.pub).  Para crear una nueva clave usamos la siguiente orden:  $ ssh-keygen -t rsa -C  Cuenta Thinstation    Warning  Tu clave RSA te identifica contra los repositorios remotos, aseg\u00farate de\nno compartir la clave privada con nadie. Por defecto la clave se crea como solo lectura .", 
            "title": "Tu clave p\u00fablica/privada"
        }, 
        {
            "location": "/usobasico/", 
            "text": "Uso b\u00e1sico de Git\n\n\nCrear un proyecto\n\n\nCrear un programa \"Hola Mundo\"\n\n\nCreamos un directorio donde colocar el c\u00f3digo\n\n\n$ mkdir curso-de-git\n$ cd curso-de-git\n\n\n\n\n\nCreamos un fichero \nhola.php\n que muestre Hola Mundo.\n\n\n?php\n\n\necho\n \nHola Mundo\n\\n\n;\n\n\n\n\n\n\nCrear el repositorio\n\n\nPara crear un nuevo repositorio se usa la orden \ngit init\n\n\n$ git init\nInitialized empty Git repository in /home/cc0gobas/git/curso-de-git/.git/\n\n\n\n\n\nA\u00f1adir la aplicaci\u00f3n\n\n\nVamos a almacenar el archivo que hemos creado en el repositorio para poder trabajar, despu\u00e9s explicaremos para qu\u00e9 sirve cada orden.\n\n\n$ git add hola.php\n$ git commit -m \nCreaci\u00f3n del proyecto\n\n[master (root-commit) e19f2c1] Creaci\u00f3n del proyecto\n 1 file changed, 2 insertions(+)\n create mode 100644 hola.php\n\n\n\n\n\nComprobar el estado del repositorio\n\n\nCon la orden \ngit status\n podemos ver en qu\u00e9 estado se encuentran los archivos de nuestro repositorio.\n\n\n$ git status\n# On branch master\nnothing to commit (working directory clean)\n\n\n\n\n\nSi modificamos el archivo \nhola.php\n:\n\n\n?php\n\n\n@\nprint\n \nHola \n{\n$argv\n[\n1\n]\n}\n\\n\n;\n\n\n\n\n\n\nY volvemos a comprobar el estado del repositorio:\n\n\n$ git status\n# On branch master\n# Changes not staged for commit:\n#   (use \ngit add \nfile\n...\n to update what will be committed)\n#   (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use \ngit add\n and/or \ngit commit -a\n)\n\n\n\n\n\nA\u00f1adir cambios\n\n\nCon la orden \ngit add\n indicamos a git que prepare los cambios para que sean almacenados.\n\n\n$ git add hola.php\n$ git status\n# On branch master\n# Changes to be committed:\n#   (use \ngit reset HEAD \nfile\n...\n to unstage)\n#\n#   modified:   hola.php\n#\n\n\n\n\n\nConfirmar los cambios\n\n\nCon la orden \ngit commit\n confirmamos los cambios definitivamente, lo que hace que se guarden permanentemente en nuestro repositorio.\n\n\n$ git commit -m \nParametrizaci\u00f3n del programa\n\n[master efc252e] Parametrizaci\u00f3n del programa\n 1 file changed, 1 insertion(+), 1 deletion(-)\n$ git status\n# On branch master\nnothing to commit (working directory clean)\n\n\n\n\n\nDiferencias entre \nworkdir\n y \nstaging\n.\n\n\nModificamos nuestra aplicaci\u00f3n para que soporte un par\u00e1metro por defecto y a\u00f1adimos los cambios.\n\n\n?php\n\n\n$nombre\n \n=\n \nisset\n(\n$argv\n[\n1\n])\n \n?\n \n$argv\n[\n1\n]\n \n:\n \nMundo\n;\n\n\n@\nprint\n \nHola, \n{\n$nombre\n}\n\\n\n;\n\n\n\n\n\n\nEste vez a\u00f1adimos los cambios a la fase de \nstaging\n pero sin confirmarlos (\ncommit\n).\n\n\ngit add hola.php\n\n\n\n\n\nVolvemos a modificar el programa para indicar con un comentario lo que hemos hecho.\n\n\n?php\n\n\n// El nombre por defecto es Mundo\n\n\n$nombre\n \n=\n \nisset\n(\n$argv\n[\n1\n])\n \n?\n \n$argv\n[\n1\n]\n \n:\n \nMundo\n;\n\n\n@\nprint\n \nHola, \n{\n$nombre\n}\n\\n\n;\n\n\n\n\n\n\nY vemos el estado en el que est\u00e1 el repositorio\n\n\n$ git status\n# On branch master\n# Changes to be committed:\n#   (use \ngit reset HEAD \nfile\n...\n to unstage)\n#\n#   modified:   hola.php\n#\n# Changes not staged for commit:\n#   (use \ngit add \nfile\n...\n to update what will be committed)\n#   (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n#\n#   modified:   hola.php\n#\n\n\n\n\n\nPodemos ver como aparecen el archivo \nhola.php\n dos veces. El primero est\u00e1 preparado\npara ser confirmado y est\u00e1 almacenado en la zona de \nstaging\n. El segundo indica\nque el directorio hola.php est\u00e1 modificado otra vez en la zona de trabajo (\nworkdir\n).\n\n\n\n\nWarning\n\n\nSi volvieramos a hacer un \ngit add hola.php\n sobreescribir\u00edamos los cambios previos\nque hab\u00eda en la zona de \nstaging\n.\n\n\n\n\nAlmacenamos los cambios por separado:\n\n\n$ git commit -m \nSe a\u00f1ade un par\u00e1metro por defecto\n\n[master 3283e0d] Se a\u00f1ade un par\u00e1metro por defecto\n 1 file changed, 2 insertions(+), 1 deletion(-)\n$ git status\n# On branch master\n# Changes not staged for commit:\n#   (use \ngit add \nfile\n...\n to update what will be committed)\n#   (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use \ngit add\n and/or \ngit commit -a\n)\n$ git add .\n$ git status\n# On branch master\n# Changes to be committed:\n#   (use \ngit reset HEAD \nfile\n...\n to unstage)\n#\n#   modified:   hola.php\n#\n$ git commit -m \nSe a\u00f1ade un comentario al cambio del valor por defecto\n\n[master fd4da94] Se a\u00f1ade un comentario al cambio del valor por defecto\n 1 file changed, 1 insertion(+)\n\n\n\n\n\n\n\nInfo\n\n\nEl valor \".\" despues de \ngit add\n indica que se a\u00f1adan todos los archivos de forma recursiva.\n\n\n\n\n\n\nWarning\n\n\nCuidado cuando uses \ngit add .\n aseg\u00farate de que no est\u00e1s a\u00f1adiendo archivos que no quieres a\u00f1adir.\n\n\n\n\nIgnorando archivos\n\n\nLa orden \ngit add .\n o \ngit add nombre_directorio\n es muy c\u00f3moda, ya que nos permite a\u00f1adir todos los archivos del proyecto o todos los contenidos en un directorio y sus subdirectorios. Es mucho m\u00e1s r\u00e1pido que tener que ir a\u00f1adi\u00e9ndolos uno por uno. El problema es que, si no se tiene cuidado, se puede terminar por a\u00f1adir archivos innecesarios o con informaci\u00f3n sensible.\n\n\nPor lo general se debe evitar a\u00f1adir archivos que se hayan generado como producto de la compilaci\u00f3n del proyecto, los que generen los entornos de desarrollo (archivos de configuraci\u00f3n y temporales) y aquellos que contentan informaci\u00f3n sensible, como contrase\u00f1as o tokens de autenticaci\u00f3n. Por ejemplo, en un proyecto de \nC/C++\n, los archivos objeto no deben incluirse, solo los que contengan c\u00f3digo fuente y los make que los generen.\n\n\nPara indicarle a \ngit\n que debe ignorar un archivo, se puede crear un fichero llamado \n.gitignore\n, bien en la ra\u00edz del proyecto o en los subdirectorios que queramos. Dicho fichero puede contener patrones, uno en cada l\u00ednea, que especiquen qu\u00e9 archivos deben ignorarse. El formato es el siguiente:\n\n\n# .gitignore\ndir1/           # ignora todo lo que contenga el directorio dir1\n!dir1/info.txt  # El operador ! excluye del ignore a dir1/info.txt (s\u00ed se guardar\u00eda)\ndir2/*.txt      # ignora todos los archivos txt que hay en el directorio dir2\ndir3/**/*.txt   # ignora todos los archivos txt que hay en el dir3 y sus subdirectorios\n*.o             # ignora todos los archivos con extensi\u00f3n .o en todos los directorios\n\n\n\n\n\nCada tipo de proyecto genera sus ficheros temporales, as\u00ed que para cada proyecto hay un \n.gitignore\n apropiado. Existen repositorios que ya tienen creadas plantillas. Pod\u00e9is encontrar uno en \nhttps://github.com/github/gitignore\n\n\nIgnorando archivos globalmente\n\n\nSi bien, los archivos que hemos metido en \n.gitignore\n, deben ser aquellos ficheros temporales o de configuraci\u00f3n que se pueden crear durante las fases de compilaci\u00f3n o ejecuci\u00f3n del programa, en ocasiones habr\u00e1 otros ficheros que tampoco debemos introducir en el repositorio y que son recurrentes en todos los proyectos. En dicho caso, es m\u00e1s \u00fatil tener un \ngitignore\n que sea global a todos nuestros proyectos. Esta configuraci\u00f3n ser\u00eda complementaria a la que ya tenemos. Ejemplos de lo que se puede ignorar de forma global son los ficheros temporales del sistema operativo (\n*~\n, \n.nfs*\n) y los que generan los entornos de desarrollo.\n\n\nPara indicar a \ngit\n que queremos tener un fichero de \ngitignore\n global, tenemos que configurarlo con la siguiente orden:\n\n\ngit config --global core.excludesfile $HOME/.gitignore_global\n\n\n\n\n\nAhora podemos crear un archivo llamado \n.gitignore_global\n en la ra\u00edz de nuestra cuenta con este contenido:\n\n\n# Compiled source #\n###################\n*.com\n*.class\n*.dll\n*.exe\n*.o\n*.so\n\n# Packages #\n############\n# it\ns better to unpack these files and commit the raw source\n# git has its own built in compression methods\n*.7z\n*.dmg\n*.gz\n*.iso\n*.jar\n*.rar\n*.tar\n*.zip\n\n# Logs and databases #\n######################\n*.log\n*.sql\n*.sqlite\n\n# OS generated files #\n######################\n.DS_Store\n.DS_Store?\n._*\n.Spotlight-V100\n.Trashes\nehthumbs.db\nThumbs.db\n*~\n*.swp\n\n# IDEs               #\n######################\n.idea\n.settings/\n.classpath\n.project\n\n\n\n\n\nTrabajando con el historial\n\n\nObservando los cambios\n\n\nCon la orden \ngit log\n podemos ver todos los cambios que hemos hecho:\n\n\n$ git log\ncommit fd4da946326fbe8b24e89282ad25a71721bf40f6\nAuthor: Sergio G\u00f3mez \nsergio@uco.es\n\nDate:   Sun Jun 16 12:51:01 2013 +0200\n\n    Se a\u00f1ade un comentario al cambio del valor por defecto\n\ncommit 3283e0d306c8d42d55ffcb64e456f10510df8177\nAuthor: Sergio G\u00f3mez \nsergio@uco.es\n\nDate:   Sun Jun 16 12:50:00 2013 +0200\n\n    Se a\u00f1ade un par\u00e1metro por defecto\n\ncommit efc252e11939351505a426a6e1aa5bb7dc1dd7c0\nAuthor: Sergio G\u00f3mez \nsergio@uco.es\n\nDate:   Sun Jun 16 12:13:26 2013 +0200\n\n    Parametrizaci\u00f3n del programa\n\ncommit e19f2c1701069d9d1159e9ee21acaa1bbc47d264\nAuthor: Sergio G\u00f3mez \nsergio@uco.es\n\nDate:   Sun Jun 16 11:55:23 2013 +0200\n\n    Creaci\u00f3n del proyecto\n\n\n\n\n\nTambi\u00e9n es posible ver versiones abreviadas o limitadas, dependiendo de los par\u00e1metros:\n\n\n$ git log --oneline\nfd4da94 Se a\u00f1ade un comentario al cambio del valor por defecto\n3283e0d Se a\u00f1ade un par\u00e1metro por defecto\nefc252e Parametrizaci\u00f3n del programa\ne19f2c1 Creaci\u00f3n del proyecto\ngit log --oneline --max-count=2\ngit log --oneline --since=\n5 minutes ago\n\ngit log --oneline --until=\n5 minutes ago\n\ngit log --oneline --author=sergio\ngit log --oneline --all\n\n\n\n\n\nUna versi\u00f3n muy \u00fatil de \ngit log\n es la siguiente, pues nos permite ver en que lugares est\u00e1 master y HEAD, entre otras cosas:\n\n\n$ git log --pretty=format:\n%h %ad | %s%d [%an]\n --graph --date=short\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (HEAD, master) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nCrear alias\n\n\nComo estas \u00f3rdenes son demasiado largas, Git nos permite crear alias para crear nuevas \u00f3rdenes parametrizadas. Para ello editaremos un archivo llamado \n.gitconfig\n que est\u00e1 en nuestro \n$HOME\n y le a\u00f1adiremos estas l\u00edneas al final:\n\n\n[alias]\n  hist = log --pretty=format:\n%h %ad | %s%d [%an]\n --graph --date=short\n\n\n\n\n\nRecuperando versiones anteriores\n\n\nCada cambio es etiquetado por un hash, para poder regresar a ese momento del estado del proyecto se usa la orden \ngit checkout\n.\n\n\n$ git checkout e19f2c1\nNote: checking out \ne19f2c1\n.\n\nYou are in \ndetached HEAD\n state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b new_branch_name\n\nHEAD is now at e19f2c1... Creaci\u00f3n del proyecto\n$ cat hola.php\n\n?php\necho \nHello, World\\n\n;\n\n\n\n\n\nEl aviso que nos sale nos indica que estamos en un estado donde no trabajamos en ninguna rama concreta. Eso significa que los cambios que hagamos podr\u00edan \"perderse\" porque si no son guardados en una nueva rama, en principio no podr\u00edamos volver a recuperarlos. Hay que pensar que Git es como un \u00e1rbol donde un nodo tiene informaci\u00f3n de su nodo padre, no de sus nodos hijos, con lo que siempre necesitar\u00edamos informaci\u00f3n de d\u00f3nde se encuentran los nodos finales o de otra manera no podr\u00edamos acceder a ellos.\n\n\nVolver a la \u00faltima versi\u00f3n de la rama master.\n\n\nUsamos \ngit checkout\n indicando el nombre de la rama:\n\n\n$ git checkout master\nPrevious HEAD position was e19f2c1... Creaci\u00f3n del proyecto\n\n\n\n\n\nEtiquetando versiones\n\n\nPara poder recuperar versiones concretas en la historia del repositorio, podemos etiquetarlas, lo cual es m\u00e1s facil que usar un hash. Para eso usaremos la orden \ngit tag\n.\n\n\n$ git tag v1\n\n\n\n\n\nAhora vamos a etiquetar la versi\u00f3n inmediatamente anterior como v1-beta. Para ello podemos usar los modificadores \n^\n o \n~\n que nos llevar\u00e1n a un ancestro determinado. Las siguientes dos \u00f3rdenes son equivalentes:\n\n\n$ git checkout v1^\n$ git checkout v1~1\n$ git tag v1-beta\n\n\n\n\n\nSi ejecutamos la orden sin par\u00e1metros nos mostrar\u00e1 todas las etiquetas existentes.\n\n\n$ git tag\nv1\nv1-beta\n\n\n\n\n\nY para verlas en el historial:\n\n\n$ git hist master --all\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1, master) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (HEAD, tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nBorrar etiquetas\n\n\nPara borrar etiquetas:\n\n\ngit tag -d nombre_etiqueta\n\n\n\n\n\nVisualizar cambios\n\n\nPara ver los cambios que se han realizado en el c\u00f3digo usamos  la orden \ngit diff\n. La orden sin especificar nada m\u00e1s, mostrar\u00e1 los cambios que no han sido a\u00f1adidos a\u00fan, es decir, todos los cambios que se han hecho antes de usar la orden \ngit add\n. Despu\u00e9s se puede indicar un par\u00e1metro y dar\u00e1 los cambios entre la versi\u00f3n indicada y el estado actual. O para comparar dos versiones entre s\u00ed, se indica la m\u00e1s antigua y la m\u00e1s nueva. Ejemplo:\n\n\n$ git diff v1-beta v1\ndiff --git a/hola.php b/hola.php\nindex a31e01f..25a35c0 100644\n--- a/hola.php\n+++ b/hola.php\n@@ -1,3 +1,4 @@\n \n?php\n+// El nombre por defecto es Mundo\n $nombre = isset($argv[1]) ? $argv[1] : \nMundo\n;\n @print \nHola, {$nombre}\\n\n;", 
            "title": "Uso b\u00e1sico"
        }, 
        {
            "location": "/usobasico/#uso-basico-de-git", 
            "text": "", 
            "title": "Uso b\u00e1sico de Git"
        }, 
        {
            "location": "/usobasico/#crear-un-proyecto", 
            "text": "", 
            "title": "Crear un proyecto"
        }, 
        {
            "location": "/usobasico/#crear-un-programa-hola-mundo", 
            "text": "Creamos un directorio donde colocar el c\u00f3digo  $ mkdir curso-de-git\n$ cd curso-de-git  Creamos un fichero  hola.php  que muestre Hola Mundo.  ?php  echo   Hola Mundo \\n ;", 
            "title": "Crear un programa \"Hola Mundo\""
        }, 
        {
            "location": "/usobasico/#crear-el-repositorio", 
            "text": "Para crear un nuevo repositorio se usa la orden  git init  $ git init\nInitialized empty Git repository in /home/cc0gobas/git/curso-de-git/.git/", 
            "title": "Crear el repositorio"
        }, 
        {
            "location": "/usobasico/#anadir-la-aplicacion", 
            "text": "Vamos a almacenar el archivo que hemos creado en el repositorio para poder trabajar, despu\u00e9s explicaremos para qu\u00e9 sirve cada orden.  $ git add hola.php\n$ git commit -m  Creaci\u00f3n del proyecto \n[master (root-commit) e19f2c1] Creaci\u00f3n del proyecto\n 1 file changed, 2 insertions(+)\n create mode 100644 hola.php", 
            "title": "A\u00f1adir la aplicaci\u00f3n"
        }, 
        {
            "location": "/usobasico/#comprobar-el-estado-del-repositorio", 
            "text": "Con la orden  git status  podemos ver en qu\u00e9 estado se encuentran los archivos de nuestro repositorio.  $ git status\n# On branch master\nnothing to commit (working directory clean)  Si modificamos el archivo  hola.php :  ?php  @ print   Hola  { $argv [ 1 ] } \\n ;   Y volvemos a comprobar el estado del repositorio:  $ git status\n# On branch master\n# Changes not staged for commit:\n#   (use  git add  file ...  to update what will be committed)\n#   (use  git checkout --  file ...  to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use  git add  and/or  git commit -a )", 
            "title": "Comprobar el estado del repositorio"
        }, 
        {
            "location": "/usobasico/#anadir-cambios", 
            "text": "Con la orden  git add  indicamos a git que prepare los cambios para que sean almacenados.  $ git add hola.php\n$ git status\n# On branch master\n# Changes to be committed:\n#   (use  git reset HEAD  file ...  to unstage)\n#\n#   modified:   hola.php\n#", 
            "title": "A\u00f1adir cambios"
        }, 
        {
            "location": "/usobasico/#confirmar-los-cambios", 
            "text": "Con la orden  git commit  confirmamos los cambios definitivamente, lo que hace que se guarden permanentemente en nuestro repositorio.  $ git commit -m  Parametrizaci\u00f3n del programa \n[master efc252e] Parametrizaci\u00f3n del programa\n 1 file changed, 1 insertion(+), 1 deletion(-)\n$ git status\n# On branch master\nnothing to commit (working directory clean)", 
            "title": "Confirmar los cambios"
        }, 
        {
            "location": "/usobasico/#diferencias-entre-workdir-y-staging", 
            "text": "Modificamos nuestra aplicaci\u00f3n para que soporte un par\u00e1metro por defecto y a\u00f1adimos los cambios.  ?php  $nombre   =   isset ( $argv [ 1 ])   ?   $argv [ 1 ]   :   Mundo ;  @ print   Hola,  { $nombre } \\n ;   Este vez a\u00f1adimos los cambios a la fase de  staging  pero sin confirmarlos ( commit ).  git add hola.php  Volvemos a modificar el programa para indicar con un comentario lo que hemos hecho.  ?php  // El nombre por defecto es Mundo  $nombre   =   isset ( $argv [ 1 ])   ?   $argv [ 1 ]   :   Mundo ;  @ print   Hola,  { $nombre } \\n ;   Y vemos el estado en el que est\u00e1 el repositorio  $ git status\n# On branch master\n# Changes to be committed:\n#   (use  git reset HEAD  file ...  to unstage)\n#\n#   modified:   hola.php\n#\n# Changes not staged for commit:\n#   (use  git add  file ...  to update what will be committed)\n#   (use  git checkout --  file ...  to discard changes in working directory)\n#\n#   modified:   hola.php\n#  Podemos ver como aparecen el archivo  hola.php  dos veces. El primero est\u00e1 preparado\npara ser confirmado y est\u00e1 almacenado en la zona de  staging . El segundo indica\nque el directorio hola.php est\u00e1 modificado otra vez en la zona de trabajo ( workdir ).   Warning  Si volvieramos a hacer un  git add hola.php  sobreescribir\u00edamos los cambios previos\nque hab\u00eda en la zona de  staging .   Almacenamos los cambios por separado:  $ git commit -m  Se a\u00f1ade un par\u00e1metro por defecto \n[master 3283e0d] Se a\u00f1ade un par\u00e1metro por defecto\n 1 file changed, 2 insertions(+), 1 deletion(-)\n$ git status\n# On branch master\n# Changes not staged for commit:\n#   (use  git add  file ...  to update what will be committed)\n#   (use  git checkout --  file ...  to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use  git add  and/or  git commit -a )\n$ git add .\n$ git status\n# On branch master\n# Changes to be committed:\n#   (use  git reset HEAD  file ...  to unstage)\n#\n#   modified:   hola.php\n#\n$ git commit -m  Se a\u00f1ade un comentario al cambio del valor por defecto \n[master fd4da94] Se a\u00f1ade un comentario al cambio del valor por defecto\n 1 file changed, 1 insertion(+)   Info  El valor \".\" despues de  git add  indica que se a\u00f1adan todos los archivos de forma recursiva.    Warning  Cuidado cuando uses  git add .  aseg\u00farate de que no est\u00e1s a\u00f1adiendo archivos que no quieres a\u00f1adir.", 
            "title": "Diferencias entre workdir y staging."
        }, 
        {
            "location": "/usobasico/#ignorando-archivos", 
            "text": "La orden  git add .  o  git add nombre_directorio  es muy c\u00f3moda, ya que nos permite a\u00f1adir todos los archivos del proyecto o todos los contenidos en un directorio y sus subdirectorios. Es mucho m\u00e1s r\u00e1pido que tener que ir a\u00f1adi\u00e9ndolos uno por uno. El problema es que, si no se tiene cuidado, se puede terminar por a\u00f1adir archivos innecesarios o con informaci\u00f3n sensible.  Por lo general se debe evitar a\u00f1adir archivos que se hayan generado como producto de la compilaci\u00f3n del proyecto, los que generen los entornos de desarrollo (archivos de configuraci\u00f3n y temporales) y aquellos que contentan informaci\u00f3n sensible, como contrase\u00f1as o tokens de autenticaci\u00f3n. Por ejemplo, en un proyecto de  C/C++ , los archivos objeto no deben incluirse, solo los que contengan c\u00f3digo fuente y los make que los generen.  Para indicarle a  git  que debe ignorar un archivo, se puede crear un fichero llamado  .gitignore , bien en la ra\u00edz del proyecto o en los subdirectorios que queramos. Dicho fichero puede contener patrones, uno en cada l\u00ednea, que especiquen qu\u00e9 archivos deben ignorarse. El formato es el siguiente:  # .gitignore\ndir1/           # ignora todo lo que contenga el directorio dir1\n!dir1/info.txt  # El operador ! excluye del ignore a dir1/info.txt (s\u00ed se guardar\u00eda)\ndir2/*.txt      # ignora todos los archivos txt que hay en el directorio dir2\ndir3/**/*.txt   # ignora todos los archivos txt que hay en el dir3 y sus subdirectorios\n*.o             # ignora todos los archivos con extensi\u00f3n .o en todos los directorios  Cada tipo de proyecto genera sus ficheros temporales, as\u00ed que para cada proyecto hay un  .gitignore  apropiado. Existen repositorios que ya tienen creadas plantillas. Pod\u00e9is encontrar uno en  https://github.com/github/gitignore", 
            "title": "Ignorando archivos"
        }, 
        {
            "location": "/usobasico/#ignorando-archivos-globalmente", 
            "text": "Si bien, los archivos que hemos metido en  .gitignore , deben ser aquellos ficheros temporales o de configuraci\u00f3n que se pueden crear durante las fases de compilaci\u00f3n o ejecuci\u00f3n del programa, en ocasiones habr\u00e1 otros ficheros que tampoco debemos introducir en el repositorio y que son recurrentes en todos los proyectos. En dicho caso, es m\u00e1s \u00fatil tener un  gitignore  que sea global a todos nuestros proyectos. Esta configuraci\u00f3n ser\u00eda complementaria a la que ya tenemos. Ejemplos de lo que se puede ignorar de forma global son los ficheros temporales del sistema operativo ( *~ ,  .nfs* ) y los que generan los entornos de desarrollo.  Para indicar a  git  que queremos tener un fichero de  gitignore  global, tenemos que configurarlo con la siguiente orden:  git config --global core.excludesfile $HOME/.gitignore_global  Ahora podemos crear un archivo llamado  .gitignore_global  en la ra\u00edz de nuestra cuenta con este contenido:  # Compiled source #\n###################\n*.com\n*.class\n*.dll\n*.exe\n*.o\n*.so\n\n# Packages #\n############\n# it s better to unpack these files and commit the raw source\n# git has its own built in compression methods\n*.7z\n*.dmg\n*.gz\n*.iso\n*.jar\n*.rar\n*.tar\n*.zip\n\n# Logs and databases #\n######################\n*.log\n*.sql\n*.sqlite\n\n# OS generated files #\n######################\n.DS_Store\n.DS_Store?\n._*\n.Spotlight-V100\n.Trashes\nehthumbs.db\nThumbs.db\n*~\n*.swp\n\n# IDEs               #\n######################\n.idea\n.settings/\n.classpath\n.project", 
            "title": "Ignorando archivos globalmente"
        }, 
        {
            "location": "/usobasico/#trabajando-con-el-historial", 
            "text": "", 
            "title": "Trabajando con el historial"
        }, 
        {
            "location": "/usobasico/#observando-los-cambios", 
            "text": "Con la orden  git log  podemos ver todos los cambios que hemos hecho:  $ git log\ncommit fd4da946326fbe8b24e89282ad25a71721bf40f6\nAuthor: Sergio G\u00f3mez  sergio@uco.es \nDate:   Sun Jun 16 12:51:01 2013 +0200\n\n    Se a\u00f1ade un comentario al cambio del valor por defecto\n\ncommit 3283e0d306c8d42d55ffcb64e456f10510df8177\nAuthor: Sergio G\u00f3mez  sergio@uco.es \nDate:   Sun Jun 16 12:50:00 2013 +0200\n\n    Se a\u00f1ade un par\u00e1metro por defecto\n\ncommit efc252e11939351505a426a6e1aa5bb7dc1dd7c0\nAuthor: Sergio G\u00f3mez  sergio@uco.es \nDate:   Sun Jun 16 12:13:26 2013 +0200\n\n    Parametrizaci\u00f3n del programa\n\ncommit e19f2c1701069d9d1159e9ee21acaa1bbc47d264\nAuthor: Sergio G\u00f3mez  sergio@uco.es \nDate:   Sun Jun 16 11:55:23 2013 +0200\n\n    Creaci\u00f3n del proyecto  Tambi\u00e9n es posible ver versiones abreviadas o limitadas, dependiendo de los par\u00e1metros:  $ git log --oneline\nfd4da94 Se a\u00f1ade un comentario al cambio del valor por defecto\n3283e0d Se a\u00f1ade un par\u00e1metro por defecto\nefc252e Parametrizaci\u00f3n del programa\ne19f2c1 Creaci\u00f3n del proyecto\ngit log --oneline --max-count=2\ngit log --oneline --since= 5 minutes ago \ngit log --oneline --until= 5 minutes ago \ngit log --oneline --author=sergio\ngit log --oneline --all  Una versi\u00f3n muy \u00fatil de  git log  es la siguiente, pues nos permite ver en que lugares est\u00e1 master y HEAD, entre otras cosas:  $ git log --pretty=format: %h %ad | %s%d [%an]  --graph --date=short\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (HEAD, master) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]", 
            "title": "Observando los cambios"
        }, 
        {
            "location": "/usobasico/#crear-alias", 
            "text": "Como estas \u00f3rdenes son demasiado largas, Git nos permite crear alias para crear nuevas \u00f3rdenes parametrizadas. Para ello editaremos un archivo llamado  .gitconfig  que est\u00e1 en nuestro  $HOME  y le a\u00f1adiremos estas l\u00edneas al final:  [alias]\n  hist = log --pretty=format: %h %ad | %s%d [%an]  --graph --date=short", 
            "title": "Crear alias"
        }, 
        {
            "location": "/usobasico/#recuperando-versiones-anteriores", 
            "text": "Cada cambio es etiquetado por un hash, para poder regresar a ese momento del estado del proyecto se usa la orden  git checkout .  $ git checkout e19f2c1\nNote: checking out  e19f2c1 .\n\nYou are in  detached HEAD  state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b new_branch_name\n\nHEAD is now at e19f2c1... Creaci\u00f3n del proyecto\n$ cat hola.php ?php\necho  Hello, World\\n ;  El aviso que nos sale nos indica que estamos en un estado donde no trabajamos en ninguna rama concreta. Eso significa que los cambios que hagamos podr\u00edan \"perderse\" porque si no son guardados en una nueva rama, en principio no podr\u00edamos volver a recuperarlos. Hay que pensar que Git es como un \u00e1rbol donde un nodo tiene informaci\u00f3n de su nodo padre, no de sus nodos hijos, con lo que siempre necesitar\u00edamos informaci\u00f3n de d\u00f3nde se encuentran los nodos finales o de otra manera no podr\u00edamos acceder a ellos.", 
            "title": "Recuperando versiones anteriores"
        }, 
        {
            "location": "/usobasico/#volver-a-la-ultima-version-de-la-rama-master", 
            "text": "Usamos  git checkout  indicando el nombre de la rama:  $ git checkout master\nPrevious HEAD position was e19f2c1... Creaci\u00f3n del proyecto", 
            "title": "Volver a la \u00faltima versi\u00f3n de la rama master."
        }, 
        {
            "location": "/usobasico/#etiquetando-versiones", 
            "text": "Para poder recuperar versiones concretas en la historia del repositorio, podemos etiquetarlas, lo cual es m\u00e1s facil que usar un hash. Para eso usaremos la orden  git tag .  $ git tag v1  Ahora vamos a etiquetar la versi\u00f3n inmediatamente anterior como v1-beta. Para ello podemos usar los modificadores  ^  o  ~  que nos llevar\u00e1n a un ancestro determinado. Las siguientes dos \u00f3rdenes son equivalentes:  $ git checkout v1^\n$ git checkout v1~1\n$ git tag v1-beta  Si ejecutamos la orden sin par\u00e1metros nos mostrar\u00e1 todas las etiquetas existentes.  $ git tag\nv1\nv1-beta  Y para verlas en el historial:  $ git hist master --all\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1, master) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (HEAD, tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]", 
            "title": "Etiquetando versiones"
        }, 
        {
            "location": "/usobasico/#borrar-etiquetas", 
            "text": "Para borrar etiquetas:  git tag -d nombre_etiqueta", 
            "title": "Borrar etiquetas"
        }, 
        {
            "location": "/usobasico/#visualizar-cambios", 
            "text": "Para ver los cambios que se han realizado en el c\u00f3digo usamos  la orden  git diff . La orden sin especificar nada m\u00e1s, mostrar\u00e1 los cambios que no han sido a\u00f1adidos a\u00fan, es decir, todos los cambios que se han hecho antes de usar la orden  git add . Despu\u00e9s se puede indicar un par\u00e1metro y dar\u00e1 los cambios entre la versi\u00f3n indicada y el estado actual. O para comparar dos versiones entre s\u00ed, se indica la m\u00e1s antigua y la m\u00e1s nueva. Ejemplo:  $ git diff v1-beta v1\ndiff --git a/hola.php b/hola.php\nindex a31e01f..25a35c0 100644\n--- a/hola.php\n+++ b/hola.php\n@@ -1,3 +1,4 @@\n  ?php\n+// El nombre por defecto es Mundo\n $nombre = isset($argv[1]) ? $argv[1] :  Mundo ;\n @print  Hola, {$nombre}\\n ;", 
            "title": "Visualizar cambios"
        }, 
        {
            "location": "/usoavanzado/", 
            "text": "Uso avanzado de Git\n\n\nDeshacer cambios\n\n\nDeshaciendo cambios antes de la fase de staging.\n\n\nVolvemos a la rama m\u00e1ster y vamos a modificar el comentario que pusimos:\n\n\n$ git checkout master\nPrevious HEAD position was 3283e0d... Se a\u00f1ade un par\u00e1metro por defecto\nSwitched to branch \nmaster\n\n\n\n\n\n\nModificamos \nhola.php\n de la siguiente manera:\n\n\n?php\n\n\n// Este comentario est\u00e1 mal y hay que borrarlo\n\n\n$nombre\n \n=\n \nisset\n(\n$argv\n[\n1\n])\n \n?\n \n$argv\n[\n1\n]\n \n:\n \nMundo\n;\n\n\n@\nprint\n \nHola, \n{\n$nombre\n}\n\\n\n;\n\n\n\n\n\n\nY comprobamos:\n\n\n$ git status\n# On branch master\n# Changes not staged for commit:\n#   (use \ngit add \nfile\n...\n to update what will be committed)\n#   (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use \ngit add\n and/or \ngit commit -a\n)\n\n\n\n\n\nEl mismo Git nos indica que debemos hacer para a\u00f1adir los cambios o para deshacerlos:\n\n\n$ git checkout hola.php\n$ git status\n# On branch master\nnothing to commit, working directory clean\n$ cat hola.php\n\n?php\n// El nombre por defecto es Mundo\n$nombre = isset($argv[1]) ? $argv[1] : \nMundo\n;\n@print \nHola, {$nombre}\\n\n;\n\n\n\n\n\nDeshaciendo cambios antes del commit\n\n\nVamos a hacer lo mismo que la vez anterior, pero esta vez s\u00ed a\u00f1adiremos el cambio al \nstaging\n (sin hacer \ncommit\n).\nAs\u00ed que volvemos a modificar \nhola.php\n igual que la anterior ocasi\u00f3n:\n\n\n?php\n\n\n// Este comentario est\u00e1 mal y hay que borrarlo\n\n\n$nombre\n \n=\n \nisset\n(\n$argv\n[\n1\n])\n \n?\n \n$argv\n[\n1\n]\n \n:\n \nMundo\n;\n\n\n@\nprint\n \nHola, \n{\n$nombre\n}\n\\n\n;\n\n\n\n\n\n\nY lo a\u00f1adimos al \nstaging\n\n\n$ git add hola.php\n$ git status\n# On branch master\n# Changes to be committed:\n#   (use \ngit reset HEAD \nfile\n...\n to unstage)\n#\n#   modified:   hola.php\n#\n\n\n\n\n\nDe nuevo, Git nos indica qu\u00e9 debemos hacer para deshacer el cambio:\n\n\n$ git reset HEAD hola.php\nUnstaged changes after reset:\nM   hola.php\n$ git status\n# On branch master\n# Changes not staged for commit:\n#   (use \ngit add \nfile\n...\n to update what will be committed)\n#   (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use \ngit add\n and/or \ngit commit -a\n)\n$ git checkout hola.php\n\n\n\n\n\nY ya tenemos nuestro repositorio limpio otra vez. Como vemos hay que hacerlo en dos pasos:\nuno para borrar los datos del \nstaging\n y otro para restaurar la copia de trabajo.\n\n\nDeshaciendo commits no deseados.\n\n\nSi a pesar de todo hemos hecho un commit y nos hemos equivocado, podemos deshacerlo con la orden \ngit revert\n.\nModificamos otra vez el archivo como antes:\n\n\n?php\n\n\n// Este comentario est\u00e1 mal y hay que borrarlo\n\n\n$nombre\n \n=\n \nisset\n(\n$argv\n[\n1\n])\n \n?\n \n$argv\n[\n1\n]\n \n:\n \nMundo\n;\n\n\n@\nprint\n \nHola, \n{\n$nombre\n}\n\\n\n;\n\n\n\n\n\n\nPero ahora s\u00ed hacemos commit:\n\n\n$ git add hola.php\n$ git commit -m \nUps... este commit est\u00e1 mal.\n\nmaster 5a5d067] Ups... este commit est\u00e1 mal\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n\n\n\n\nBien, una vez confirmado el cambio, vamos a deshacer el cambio con la orden \ngit revert\n:\n\n\n$ git revert HEAD --no-edit\n[master 817407b] Revert \nUps... este commit est\u00e1 mal\n\n1 file changed, 1 insertion(+), 1 deletion(-)\n$ git hist\n* 817407b 2013-06-16 | Revert \nUps... este commit est\u00e1 mal\n (HEAD, master) [Sergio G\u00f3mez]\n* 5a5d067 2013-06-16 | Ups... este commit est\u00e1 mal [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nBorrar commits de una rama\n\n\nEl anterior apartado revierte un commit, pero deja huella en el historial de cambios. Para hacer que no aparezca hay que usar la orden \ngit reset\n.\n\n\n$ git reset --hard v1\nHEAD is now at fd4da94 Se a\u00f1ade un comentario al cambio del valor por defecto\n$ git hist\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (HEAD, tag: v1, master) [Sergio G\u00f3me\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nEl resto de cambios no se han borrado (a\u00fan), simplemente no est\u00e1n accesibles porque git no sabe como referenciarlos. Si sabemos su hash podemos acceder a\u00fan a ellos. Pasado un tiempo, eventualmente Git tiene un recolector de basura que los borrar\u00e1. Se puede evitar etiquetando el estado final.\n\n\n\n\nDanger\n\n\nLa orden \nreset\n es una operaci\u00f3n delicada. Debe evitarse si no se sabe bien lo que se est\u00e1 haciendo,\nsobre todo cuando se trabaja en repositorios compartidos, porque podr\u00edamos alterar la historia de cambios\nlo cual puede provocar problemas de sincronizaci\u00f3n.\n\n\n\n\nModificar un commit\n\n\nEsto se usa cuando hemos olvidado a\u00f1adir un cambio a un commit que acabamos de realizar. Tenemos\nnuestro archivo \nhola.php\n de la siguiente manera:\n\n\n?php\n\n\n// Autor: Sergio G\u00f3mez\n\n\n// El nombre por defecto es Mundo\n\n\n$nombre\n \n=\n \nisset\n(\n$argv\n[\n1\n])\n \n?\n \n$argv\n[\n1\n]\n \n:\n \nMundo\n;\n\n\n@\nprint\n \nHola, \n{\n$nombre\n}\n\\n\n;\n\n\n\n\n\n\nY lo confirmamos:\n\n\n$ git commit -a -m \nA\u00f1adido el autor del programa\n\n[master cf405c1] A\u00f1adido el autor del programa\n 1 file changed, 1 insertion(+)\n\n\n\n\n\n\n\nTip\n\n\nEl par\u00e1metro \n-a\n hace un \ngit add\n antes de hacer \ncommit\n de todos los archivos modificados\n o borrados (de los nuevos no), con lo que nos ahorramos un paso.\n\n\n\n\nAhora nos percatamos que se nos ha olvidado poner el correo electr\u00f3nico. As\u00ed que volvemos a modificar nuestro archivo:\n\n\n?php\n\n\n// Autor: Sergio G\u00f3mez \nsergio@uco.es\n\n\n// El nombre por defecto es Mundo\n\n\n$nombre\n \n=\n \nisset\n(\n$argv\n[\n1\n])\n \n?\n \n$argv\n[\n1\n]\n \n:\n \nMundo\n;\n\n\n@\nprint\n \nHola, \n{\n$nombre\n}\n\\n\n;\n\n\n\n\n\n\nY en esta ocasi\u00f3n usamos \ncommit --amend\n que nos permite modificar el \u00faltimo estado confirmado, sustituy\u00e9ndolo por el estado actual:\n\n\n$ git add hola.php\n$ git commit --amend -m \nA\u00f1adido el autor del programa y su email\n\n[master 96a39df] A\u00f1adido el autor del programa y su email\n 1 file changed, 1 insertion(+)\n$ git hist\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email (HEAD, master) [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\n\n\nDanger\n\n\nNunca modifiques un \ncommit\n que ya hayas sincronizado con otro repositorio o\nque hayas recibido de \u00e9l. Estar\u00edas alterando la historia de cambios y provocar\u00edas\nproblemas de sincronizaci\u00f3n.\n\n\n\n\nMoviendo y borrando archivos\n\n\nMover un archivo a otro directorio con git\n\n\nPara mover archivos usaremos la orden \ngit mv\n:\n\n\n$ mkdir lib\n$ git mv hola.php lib\n$ git status\n# On branch master\n# Changes to be committed:\n#   (use \ngit reset HEAD \nfile\n...\n to unstage)\n#\n#   renamed:    hola.php -\n lib/hola.php\n#\n\n\n\n\n\nMover y borrar archivos.\n\n\nPod\u00edamos haber hecho el paso anterior con la \u00f3rden del sistema \nmv\n y el resultado hubiera sido el mismo. Lo siguiente es a modo de ejemplo y no es necesario que lo ejecutes:\n\n\n$ mkdir lib\n$ mv hola.php lib\n$ git add lib/hola.php\n$ git rm hola.php\n\n\n\n\n\nY, ahora s\u00ed, ya podemos guardar los cambios:\n\n\n$ git commit -m \nMovido hola.php a lib.\n\n[master 8c2a509] Movido hola.php a lib.\n 1 file changed, 0 insertions(+), 0 deletions(-)\n rename hola.php =\n lib/hola.php (100%)", 
            "title": "Uso avanzado"
        }, 
        {
            "location": "/usoavanzado/#uso-avanzado-de-git", 
            "text": "", 
            "title": "Uso avanzado de Git"
        }, 
        {
            "location": "/usoavanzado/#deshacer-cambios", 
            "text": "", 
            "title": "Deshacer cambios"
        }, 
        {
            "location": "/usoavanzado/#deshaciendo-cambios-antes-de-la-fase-de-staging", 
            "text": "Volvemos a la rama m\u00e1ster y vamos a modificar el comentario que pusimos:  $ git checkout master\nPrevious HEAD position was 3283e0d... Se a\u00f1ade un par\u00e1metro por defecto\nSwitched to branch  master   Modificamos  hola.php  de la siguiente manera:  ?php  // Este comentario est\u00e1 mal y hay que borrarlo  $nombre   =   isset ( $argv [ 1 ])   ?   $argv [ 1 ]   :   Mundo ;  @ print   Hola,  { $nombre } \\n ;   Y comprobamos:  $ git status\n# On branch master\n# Changes not staged for commit:\n#   (use  git add  file ...  to update what will be committed)\n#   (use  git checkout --  file ...  to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use  git add  and/or  git commit -a )  El mismo Git nos indica que debemos hacer para a\u00f1adir los cambios o para deshacerlos:  $ git checkout hola.php\n$ git status\n# On branch master\nnothing to commit, working directory clean\n$ cat hola.php ?php\n// El nombre por defecto es Mundo\n$nombre = isset($argv[1]) ? $argv[1] :  Mundo ;\n@print  Hola, {$nombre}\\n ;", 
            "title": "Deshaciendo cambios antes de la fase de staging."
        }, 
        {
            "location": "/usoavanzado/#deshaciendo-cambios-antes-del-commit", 
            "text": "Vamos a hacer lo mismo que la vez anterior, pero esta vez s\u00ed a\u00f1adiremos el cambio al  staging  (sin hacer  commit ).\nAs\u00ed que volvemos a modificar  hola.php  igual que la anterior ocasi\u00f3n:  ?php  // Este comentario est\u00e1 mal y hay que borrarlo  $nombre   =   isset ( $argv [ 1 ])   ?   $argv [ 1 ]   :   Mundo ;  @ print   Hola,  { $nombre } \\n ;   Y lo a\u00f1adimos al  staging  $ git add hola.php\n$ git status\n# On branch master\n# Changes to be committed:\n#   (use  git reset HEAD  file ...  to unstage)\n#\n#   modified:   hola.php\n#  De nuevo, Git nos indica qu\u00e9 debemos hacer para deshacer el cambio:  $ git reset HEAD hola.php\nUnstaged changes after reset:\nM   hola.php\n$ git status\n# On branch master\n# Changes not staged for commit:\n#   (use  git add  file ...  to update what will be committed)\n#   (use  git checkout --  file ...  to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use  git add  and/or  git commit -a )\n$ git checkout hola.php  Y ya tenemos nuestro repositorio limpio otra vez. Como vemos hay que hacerlo en dos pasos:\nuno para borrar los datos del  staging  y otro para restaurar la copia de trabajo.", 
            "title": "Deshaciendo cambios antes del commit"
        }, 
        {
            "location": "/usoavanzado/#deshaciendo-commits-no-deseados", 
            "text": "Si a pesar de todo hemos hecho un commit y nos hemos equivocado, podemos deshacerlo con la orden  git revert .\nModificamos otra vez el archivo como antes:  ?php  // Este comentario est\u00e1 mal y hay que borrarlo  $nombre   =   isset ( $argv [ 1 ])   ?   $argv [ 1 ]   :   Mundo ;  @ print   Hola,  { $nombre } \\n ;   Pero ahora s\u00ed hacemos commit:  $ git add hola.php\n$ git commit -m  Ups... este commit est\u00e1 mal. \nmaster 5a5d067] Ups... este commit est\u00e1 mal\n 1 file changed, 1 insertion(+), 1 deletion(-)  Bien, una vez confirmado el cambio, vamos a deshacer el cambio con la orden  git revert :  $ git revert HEAD --no-edit\n[master 817407b] Revert  Ups... este commit est\u00e1 mal \n1 file changed, 1 insertion(+), 1 deletion(-)\n$ git hist\n* 817407b 2013-06-16 | Revert  Ups... este commit est\u00e1 mal  (HEAD, master) [Sergio G\u00f3mez]\n* 5a5d067 2013-06-16 | Ups... este commit est\u00e1 mal [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]", 
            "title": "Deshaciendo commits no deseados."
        }, 
        {
            "location": "/usoavanzado/#borrar-commits-de-una-rama", 
            "text": "El anterior apartado revierte un commit, pero deja huella en el historial de cambios. Para hacer que no aparezca hay que usar la orden  git reset .  $ git reset --hard v1\nHEAD is now at fd4da94 Se a\u00f1ade un comentario al cambio del valor por defecto\n$ git hist\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (HEAD, tag: v1, master) [Sergio G\u00f3me\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  El resto de cambios no se han borrado (a\u00fan), simplemente no est\u00e1n accesibles porque git no sabe como referenciarlos. Si sabemos su hash podemos acceder a\u00fan a ellos. Pasado un tiempo, eventualmente Git tiene un recolector de basura que los borrar\u00e1. Se puede evitar etiquetando el estado final.   Danger  La orden  reset  es una operaci\u00f3n delicada. Debe evitarse si no se sabe bien lo que se est\u00e1 haciendo,\nsobre todo cuando se trabaja en repositorios compartidos, porque podr\u00edamos alterar la historia de cambios\nlo cual puede provocar problemas de sincronizaci\u00f3n.", 
            "title": "Borrar commits de una rama"
        }, 
        {
            "location": "/usoavanzado/#modificar-un-commit", 
            "text": "Esto se usa cuando hemos olvidado a\u00f1adir un cambio a un commit que acabamos de realizar. Tenemos\nnuestro archivo  hola.php  de la siguiente manera:  ?php  // Autor: Sergio G\u00f3mez  // El nombre por defecto es Mundo  $nombre   =   isset ( $argv [ 1 ])   ?   $argv [ 1 ]   :   Mundo ;  @ print   Hola,  { $nombre } \\n ;   Y lo confirmamos:  $ git commit -a -m  A\u00f1adido el autor del programa \n[master cf405c1] A\u00f1adido el autor del programa\n 1 file changed, 1 insertion(+)   Tip  El par\u00e1metro  -a  hace un  git add  antes de hacer  commit  de todos los archivos modificados\n o borrados (de los nuevos no), con lo que nos ahorramos un paso.   Ahora nos percatamos que se nos ha olvidado poner el correo electr\u00f3nico. As\u00ed que volvemos a modificar nuestro archivo:  ?php  // Autor: Sergio G\u00f3mez  sergio@uco.es  // El nombre por defecto es Mundo  $nombre   =   isset ( $argv [ 1 ])   ?   $argv [ 1 ]   :   Mundo ;  @ print   Hola,  { $nombre } \\n ;   Y en esta ocasi\u00f3n usamos  commit --amend  que nos permite modificar el \u00faltimo estado confirmado, sustituy\u00e9ndolo por el estado actual:  $ git add hola.php\n$ git commit --amend -m  A\u00f1adido el autor del programa y su email \n[master 96a39df] A\u00f1adido el autor del programa y su email\n 1 file changed, 1 insertion(+)\n$ git hist\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email (HEAD, master) [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]   Danger  Nunca modifiques un  commit  que ya hayas sincronizado con otro repositorio o\nque hayas recibido de \u00e9l. Estar\u00edas alterando la historia de cambios y provocar\u00edas\nproblemas de sincronizaci\u00f3n.", 
            "title": "Modificar un commit"
        }, 
        {
            "location": "/usoavanzado/#moviendo-y-borrando-archivos", 
            "text": "", 
            "title": "Moviendo y borrando archivos"
        }, 
        {
            "location": "/usoavanzado/#mover-un-archivo-a-otro-directorio-con-git", 
            "text": "Para mover archivos usaremos la orden  git mv :  $ mkdir lib\n$ git mv hola.php lib\n$ git status\n# On branch master\n# Changes to be committed:\n#   (use  git reset HEAD  file ...  to unstage)\n#\n#   renamed:    hola.php -  lib/hola.php\n#", 
            "title": "Mover un archivo a otro directorio con git"
        }, 
        {
            "location": "/usoavanzado/#mover-y-borrar-archivos", 
            "text": "Pod\u00edamos haber hecho el paso anterior con la \u00f3rden del sistema  mv  y el resultado hubiera sido el mismo. Lo siguiente es a modo de ejemplo y no es necesario que lo ejecutes:  $ mkdir lib\n$ mv hola.php lib\n$ git add lib/hola.php\n$ git rm hola.php  Y, ahora s\u00ed, ya podemos guardar los cambios:  $ git commit -m  Movido hola.php a lib. \n[master 8c2a509] Movido hola.php a lib.\n 1 file changed, 0 insertions(+), 0 deletions(-)\n rename hola.php =  lib/hola.php (100%)", 
            "title": "Mover y borrar archivos."
        }, 
        {
            "location": "/ramas/", 
            "text": "Ramas\n\n\nAdministraci\u00f3n de ramas\n\n\nCrear una nueva rama\n\n\nCuando vamos a trabajar en una nueva funcionalidad, es conveniente hacerlo en una nueva rama, para no modificar la rama principal y dejarla inestable. Aunque la orden para manejar ramas es \ngit branch\n podemos usar tambi\u00e9n \ngit checkout\n.\n\n\nVamos a crear una nueva rama:\n\n\ngit branch hola\n\n\n\n\n\n\n\nInfo\n\n\nSi usamos \ngit branch\n sin ning\u00fan argumento, nos devolver\u00e1 la lista de ramas\ndisponibles.\n\n\n\n\nLa orden anterior no devuelve ning\u00fan resultado y tampoco nos cambia de rama, para eso\ndebemos usar \ncheckout\n:\n\n\n$ git checkout hola\nSwitched to branch \nhola\n\n\n\n\n\n\n\n\nTip\n\n\nHay una forma m\u00e1s rapida de hacer ambas acciones en un solo paso. Con el par\u00e1metro\n\n-b\n de \ngit checkout\n podemos cambiarnos a una rama que, si no existe, se crea\ninstant\u00e1neamente.\n\n\n$ git checkout -b hola\nSwitched to a new branch \nhola\n\n\n\n\n\n\n\n\nModificaciones en la rama secundaria\n\n\nA\u00f1adimos un nuevo archivo en el directorio \nlib\n llamado \nHolaMundo.php\n:\n\n\n?php\n\n\n\nclass\n \nHolaMundo\n\n\n{\n\n   \nprivate\n \n$nombre\n;\n\n\n   \nfunction\n \n__construct\n(\n$nombre\n)\n\n   \n{\n\n      \n$this\n-\nnombre\n \n=\n \n$nombre\n;\n\n   \n}\n\n\n   \nfunction\n \n__toString\n()\n\n   \n{\n\n      \nreturn\n \nsprintf\n \n(\nHola, %s.\n\\n\n,\n \n$this\n-\nnombre\n);\n\n   \n}\n\n\n}\n\n\n\n\n\n\nY modificamos \nhola.php\n:\n\n\n?php\n\n\n// Autor: Sergio G\u00f3mez \nsergio@uco.es\n\n\n// El nombre por defecto es Mundo\n\n\nrequire\n(\nHolaMundo.php\n);\n\n\n\n$nombre\n \n=\n \nisset\n(\n$argv\n[\n1\n])\n \n?\n \n$argv\n[\n1\n]\n \n:\n \nMundo\n;\n\n\nprint\n \nnew\n \nHolaMundo\n(\n$nombre\n);\n\n\n\n\n\n\nPodr\u00edamos confirmar los cambios todos de golpe, pero lo haremos de uno en uno, con su comentario.\n\n\n$ git add lib/HolaMundo.php\n$ git commit -m \nA\u00f1adida la clase HolaMundo\n\n[hola 6932156] A\u00f1adida la clase HolaMundo\n 1 file changed, 16 insertions(+)\n create mode 100644 lib/HolaMundo.php\n$ git add lib/hola.php\n$ git commit -m \nhola usa la clase HolaMundo\n\n[hola 9862f33] hola usa la clase HolaMundo\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n\n\n\n\nY ahora con la orden \ngit checkout\n podemos movernos entre ramas:\n\n\n$ git checkout master\nSwitched to branch \nmaster\n\n$ git checkout hola\nSwitched to branch \nhola\n\n\n\n\n\n\nModificaciones en la rama master\n\n\nPodemos volver y a\u00f1adir un nuevo archivo a la rama principal:\n\n\n$ git checkout master\nSwitched to branch \nmaster\n\n\n\n\n\n\nCreamos un archivo llamado \nREADME.md\n en la ra\u00edz de nuestro proyecto con el siguiente contenido:\n\n\n#\n Curso de GIT\n\nEste proyecto contiene el curso de introducci\u00f3n a GIT\n\n\n\n\n\nY lo a\u00f1adimos a nuestro repositorio en la rama en la que estamos:\n\n\n$ git add README.md\n$ git commit -m \nA\u00f1adido README.md\n\n[master c3e65d0] A\u00f1adido README.md\n 1 file changed, 3 insertions(+)\n create mode 100644 README.md\n$ git hist --all\n* c3e65d0 2013-06-16 | A\u00f1adido README.md (HEAD, master) [Sergio G\u00f3mez]\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/  \n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nY vemos como \ngit hist\n muestra la bifurcaci\u00f3n en nuestro c\u00f3digo.\n\n\nFusi\u00f3n de ramas y resoluci\u00f3n de conflictos\n\n\nMezclar ramas\n\n\nPodemos incorporar los cambios de una rama a otra con la orden \ngit merge\n\n\n$ git checkout hola\nSwitched to branch \nhola\n\n$ git merge master\nMerge made by the \nrecursive\n strategy.\n README.md | 3 +++\n 1 file changed, 3 insertions(+)\n create mode 100644 README.md\n$ git hist --all\n*   9c6ac06 2013-06-16 | Merge commit \nc3e65d0\n into hola (HEAD, hola) [Sergio G\u00f3mez]\n|\\  \n* | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez]\n* | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n| |\n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n|/  \n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nDe esa forma se puede trabajar en una rama secundaria incorporando los cambios de la rama principal o de otra rama.\n\n\nResolver conflictos\n\n\nUn conflicto es cuando se produce una fusi\u00f3n que Git no es capaz de resolver. Vamos a modificar la rama master para crear uno con la rama hola.\n\n\n$ git checkout master\nSwitched to branch \nmaster\n\n\n\n\n\n\nModificamos nuestro archivo \nhola.php\n de nuevo:\n\n\n?php\n\n\n// Autor: Sergio G\u00f3mez \nsergio@uco.es\n\n\nprint\n \nIntroduce tu nombre:\n;\n\n\n$nombre\n \n=\n \ntrim\n(\nfgets\n(\nSTDIN\n));\n\n\n@\nprint\n \nHola, \n{\n$nombre\n}\n\\n\n;\n\n\n\n\n\n\nY guardamos los cambios:\n\n\n$ git add lib/hola.php\n$ git commit -m \nPrograma interactivo\n\n[master 9c85275] Programa interactivo\n 1 file changed, 2 insertions(+), 2 deletions(-)\n$ git hist --all\n*   9c6ac06 2013-06-16 | Merge commit \nc3e65d0\n into hola (hola) [Sergio G\u00f3mez]\n|\\  \n* | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez]\n* | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n| | * 9c85275 2013-06-16 | Programa interactivo (HEAD, master) [Sergio G\u00f3mez]\n| |/  \n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n|/  \n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nVolvemos a la rama hola y fusionamos:\n\n\n$ git checkout hola\nSwitched to branch \nhola\n\n$ git merge master\nAuto-merging lib/hola.php\nCONFLICT (content): Merge conflict in lib/hola.php\nAutomatic merge failed; fix conflicts and then commit the result.\n\n\n\n\n\nSi editamos nuestro archivo \nlib/hola.php\n obtendremos algo similar a esto:\n\n\n?php\n\n\n// Autor: Sergio G\u00f3mez \nsergio@uco.es\n\n\n \nHEAD\n\n\n// El nombre por defecto es Mundo\n\n\nrequire\n(\nHolaMundo.php\n);\n\n\n\n$nombre\n \n=\n \nisset\n(\n$argv\n[\n1\n])\n \n?\n \n$argv\n[\n1\n]\n \n:\n \nMundo\n;\n\n\nprint\n \nnew\n \nHolaMundo\n(\n$nombre\n);\n\n\n=======\n\n\nprint\n \nIntroduce tu nombre:\n;\n\n\n$nombre\n \n=\n \ntrim\n(\nfgets\n(\nSTDIN\n));\n\n\n@\nprint\n \nHola, \n{\n$nombre\n}\n\\n\n;\n\n\n \nmaster\n\n\n\n\n\n\nLa primera parte marca el c\u00f3digo que estaba en la rama donde trabaj\u00e1bamos (HEAD) y la parte final el c\u00f3digo de donde fusion\u00e1bamos. Resolvemos el conflicto, dejando el archivo como sigue:\n\n\n?php\n\n\n// Autor: Sergio G\u00f3mez \nsergio@uco.es\n\n\nrequire\n(\nHolaMundo.php\n);\n\n\n\nprint\n \nIntroduce tu nombre:\n;\n\n\n$nombre\n \n=\n \ntrim\n(\nfgets\n(\nSTDIN\n));\n\n\nprint\n \nnew\n \nHolaMundo\n(\n$nombre\n);\n\n\n\n\n\n\nY resolvemos el conflicto confirmando los cambios:\n\n\n$ git add lib/hola.php\n$ git commit -m \nSolucionado el conflicto al fusionar con la rama master\n\n[hola a36af04] Solucionado el conflicto al fusionar con la rama master\n\n\n\n\n\nRebasing vs Merging\n\n\nRebasing es otra t\u00e9cnica para fusionar distinta a merge y usa la orden \ngit rebase\n. Vamos a dejar nuestro proyecto como estaba antes del fusionado. Para ello necesitamos anotar el hash anterior al de la acci\u00f3n de \nmerge\n. El que tiene la anotaci\u00f3n \n\"hola usa la clase HolaMundo\"\n.\n\n\nPara ello podemos usar la orden \ngit reset\n que nos permite mover HEAD donde queramos.\n\n\n$ git checkout hola\nSwitched to branch \nhola\n\n$ git hist\n*   a36af04 2013-06-16 | Solucionado el conflicto al fusionar con la rama master (HEAD, hola) [Sergio G\u00f3mez]\n|\\  \n| * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* |   9c6ac06 2013-06-16 | Merge commit \nc3e65d0\n into hola [Sergio G\u00f3mez]\n|\\ \\  \n| |/  \n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez]\n* | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/  \n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n$ git reset --hard 9862f33\nHEAD is now at 9862f33 hola usa la clase HolaMundo\n\n\n\n\n\nY nuestro estado ser\u00e1:\n\n\n$ git hist --all\n* 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD, hola) [Sergio G\u00f3mez]\n* 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n| * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n|/  \n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nHemos desecho todos los \nmerge\n y nuestro \u00e1rbol est\u00e1 \n\"limpio\"\n. Vamos a probar ahora a hacer un rebase. Continuamos en la rama \nhola\n y ejecutamos lo siguiente:\n\n\n$ git rebase master\nFirst, rewinding head to replay your work on top of it...\nApplying: A\u00f1adida la clase HolaMundo\nApplying: hola usa la clase HolaMundo\nUsing index info to reconstruct a base tree...\nM   lib/hola.php\nFalling back to patching base and 3-way merge...\nAuto-merging lib/hola.php\nCONFLICT (content): Merge conflict in lib/hola.php\nerror: Failed to merge in the changes.\nPatch failed at 0002 hola usa la clase HolaMundo\nThe copy of the patch that failed is found in: .git/rebase-apply/patch\n\nWhen you have resolved this problem, run \ngit rebase --continue\n.\nIf you prefer to skip this patch, run \ngit rebase --skip\n instead.\nTo check out the original branch and stop rebasing, run \ngit rebase --abort\n.\n\n\n\n\n\nEl conflicto, por supuesto, se sigue dando. Resolvemos guardando el archivo \nhola.php\n como en los casos anteriores:\n\n\n?php\n\n\n// Autor: Sergio G\u00f3mez \nsergio@uco.es\n\n\nrequire\n(\nHolaMundo.php\n);\n\n\n\nprint\n \nIntroduce tu nombre:\n;\n\n\n$nombre\n \n=\n \ntrim\n(\nfgets\n(\nSTDIN\n));\n\n\nprint\n \nnew\n \nHolaMundo\n(\n$nombre\n);\n\n\n\n\n\n\nA\u00f1adimos los cambios en \nstaging\n y en esta ocasi\u00f3n, y tal como nos indicaba en el mensaje anterior, no tenemos que hacer \ngit commit\n sino continuar con el \nrebase\n:\n\n\n$ git add lib/hola.php\n$ git status\nrebase in progress; onto 269eaca\nYou are currently rebasing branch \nhola\n on \n269eaca\n.\n  (all conflicts fixed: run \ngit rebase --continue\n)\n\nChanges to be committed:\n  (use \ngit reset HEAD \nfile\n...\n to unstage)\n\n    modified:   lib/hola.php\n$ git rebase --continue\nApplying: hola usa la clase HolaMundo\n\n\n\n\n\nY ahora vemos que nuestro \u00e1rbol tiene un aspecto distinto, mucho m\u00e1s limpio:\n\n\n$ git hist --all\n* 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -\n hola) [Sergio G\u00f3mez]\n* 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nLo que hace rebase es volver a aplicar todos los cambios a la rama m\u00e1ster, desde su nodo m\u00e1s reciente. Eso significa que se modifica el orden o la historia de creaci\u00f3n de los cambios. Por eso rebase no debe usarse si el orden es importante o si la rama es compartida.\n\n\nMezclando con la rama master\n\n\nYa hemos terminado de implementar los cambios en nuestra rama secundaria y es hora de llevar los cambios a la rama principal. Usamos \ngit merge\n para hacer una fusi\u00f3n normal:\n\n\n$ git checkout master\nSwitched to branch \nmaster\n\n$ git merge hola\nUpdating c3e65d0..491f1d2\nFast-forward\n lib/HolaMundo.php | 16 ++++++++++++++++\n lib/hola.php      |  4 +++-\n 2 files changed, 19 insertions(+), 1 deletion(-)\n create mode 100644 lib/HolaMundo.php\n $ git hist --all\n * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -\n master, hola) [Sergio G\u00f3mez]\n * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n * 9c85275 2013-06-16 | Programa interactivo [Sergio G\u00f3mez]\n * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nVemos que indica que el tipo de fusi\u00f3n es \nfast-forward\n. Este tipo de fusi\u00f3n tiene el problema que no deja rastro de la fusi\u00f3n, por eso suele ser recomendable usar el par\u00e1metro  \n--no-ff\n para que quede constancia siempre de que se ha fusionado una rama con otra.\n\n\nVamos a volver a probar ahora sin hacer \nfast-forward\n. Reseteamos \nmaster\n al estado \n\"Programa interactivo\"\n.\n\n\n$ git reset --hard 9c85275\n$ git hist --all\n* 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -\n hola) [Sergio G\u00f3mez]\n* 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nVemos que estamos como en el final de la secci\u00f3n anterior, as\u00ed que ahora mezclamos:\n\n\n$ git merge -m \nAplicando los cambios de la rama hola\n --no-ff hola\nMerge made by the \nrecursive\n strategy.\n lib/HolaMundo.php | 16 ++++++++++++++++\n lib/hola.php      |  4 +++-\n 2 files changed, 19 insertions(+), 1 deletion(-)\n create mode 100644 lib/HolaMundo.php\n$ git hist --all\n*   2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (HEAD -\n master) [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nEn la siguiente imagen se puede ver la diferencia:", 
            "title": "Ramas"
        }, 
        {
            "location": "/ramas/#ramas", 
            "text": "", 
            "title": "Ramas"
        }, 
        {
            "location": "/ramas/#administracion-de-ramas", 
            "text": "", 
            "title": "Administraci\u00f3n de ramas"
        }, 
        {
            "location": "/ramas/#crear-una-nueva-rama", 
            "text": "Cuando vamos a trabajar en una nueva funcionalidad, es conveniente hacerlo en una nueva rama, para no modificar la rama principal y dejarla inestable. Aunque la orden para manejar ramas es  git branch  podemos usar tambi\u00e9n  git checkout .  Vamos a crear una nueva rama:  git branch hola   Info  Si usamos  git branch  sin ning\u00fan argumento, nos devolver\u00e1 la lista de ramas\ndisponibles.   La orden anterior no devuelve ning\u00fan resultado y tampoco nos cambia de rama, para eso\ndebemos usar  checkout :  $ git checkout hola\nSwitched to branch  hola    Tip  Hay una forma m\u00e1s rapida de hacer ambas acciones en un solo paso. Con el par\u00e1metro -b  de  git checkout  podemos cambiarnos a una rama que, si no existe, se crea\ninstant\u00e1neamente.  $ git checkout -b hola\nSwitched to a new branch  hola", 
            "title": "Crear una nueva rama"
        }, 
        {
            "location": "/ramas/#modificaciones-en-la-rama-secundaria", 
            "text": "A\u00f1adimos un nuevo archivo en el directorio  lib  llamado  HolaMundo.php :  ?php  class   HolaMundo  { \n    private   $nombre ; \n\n    function   __construct ( $nombre ) \n    { \n       $this - nombre   =   $nombre ; \n    } \n\n    function   __toString () \n    { \n       return   sprintf   ( Hola, %s. \\n ,   $this - nombre ); \n    }  }   Y modificamos  hola.php :  ?php  // Autor: Sergio G\u00f3mez  sergio@uco.es  // El nombre por defecto es Mundo  require ( HolaMundo.php );  $nombre   =   isset ( $argv [ 1 ])   ?   $argv [ 1 ]   :   Mundo ;  print   new   HolaMundo ( $nombre );   Podr\u00edamos confirmar los cambios todos de golpe, pero lo haremos de uno en uno, con su comentario.  $ git add lib/HolaMundo.php\n$ git commit -m  A\u00f1adida la clase HolaMundo \n[hola 6932156] A\u00f1adida la clase HolaMundo\n 1 file changed, 16 insertions(+)\n create mode 100644 lib/HolaMundo.php\n$ git add lib/hola.php\n$ git commit -m  hola usa la clase HolaMundo \n[hola 9862f33] hola usa la clase HolaMundo\n 1 file changed, 3 insertions(+), 1 deletion(-)  Y ahora con la orden  git checkout  podemos movernos entre ramas:  $ git checkout master\nSwitched to branch  master \n$ git checkout hola\nSwitched to branch  hola", 
            "title": "Modificaciones en la rama secundaria"
        }, 
        {
            "location": "/ramas/#modificaciones-en-la-rama-master", 
            "text": "Podemos volver y a\u00f1adir un nuevo archivo a la rama principal:  $ git checkout master\nSwitched to branch  master   Creamos un archivo llamado  README.md  en la ra\u00edz de nuestro proyecto con el siguiente contenido:  #  Curso de GIT\n\nEste proyecto contiene el curso de introducci\u00f3n a GIT  Y lo a\u00f1adimos a nuestro repositorio en la rama en la que estamos:  $ git add README.md\n$ git commit -m  A\u00f1adido README.md \n[master c3e65d0] A\u00f1adido README.md\n 1 file changed, 3 insertions(+)\n create mode 100644 README.md\n$ git hist --all\n* c3e65d0 2013-06-16 | A\u00f1adido README.md (HEAD, master) [Sergio G\u00f3mez]\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/  \n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Y vemos como  git hist  muestra la bifurcaci\u00f3n en nuestro c\u00f3digo.", 
            "title": "Modificaciones en la rama master"
        }, 
        {
            "location": "/ramas/#fusion-de-ramas-y-resolucion-de-conflictos", 
            "text": "", 
            "title": "Fusi\u00f3n de ramas y resoluci\u00f3n de conflictos"
        }, 
        {
            "location": "/ramas/#mezclar-ramas", 
            "text": "Podemos incorporar los cambios de una rama a otra con la orden  git merge  $ git checkout hola\nSwitched to branch  hola \n$ git merge master\nMerge made by the  recursive  strategy.\n README.md | 3 +++\n 1 file changed, 3 insertions(+)\n create mode 100644 README.md\n$ git hist --all\n*   9c6ac06 2013-06-16 | Merge commit  c3e65d0  into hola (HEAD, hola) [Sergio G\u00f3mez]\n|\\  \n* | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez]\n* | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n| |\n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n|/  \n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  De esa forma se puede trabajar en una rama secundaria incorporando los cambios de la rama principal o de otra rama.", 
            "title": "Mezclar ramas"
        }, 
        {
            "location": "/ramas/#resolver-conflictos", 
            "text": "Un conflicto es cuando se produce una fusi\u00f3n que Git no es capaz de resolver. Vamos a modificar la rama master para crear uno con la rama hola.  $ git checkout master\nSwitched to branch  master   Modificamos nuestro archivo  hola.php  de nuevo:  ?php  // Autor: Sergio G\u00f3mez  sergio@uco.es  print   Introduce tu nombre: ;  $nombre   =   trim ( fgets ( STDIN ));  @ print   Hola,  { $nombre } \\n ;   Y guardamos los cambios:  $ git add lib/hola.php\n$ git commit -m  Programa interactivo \n[master 9c85275] Programa interactivo\n 1 file changed, 2 insertions(+), 2 deletions(-)\n$ git hist --all\n*   9c6ac06 2013-06-16 | Merge commit  c3e65d0  into hola (hola) [Sergio G\u00f3mez]\n|\\  \n* | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez]\n* | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n| | * 9c85275 2013-06-16 | Programa interactivo (HEAD, master) [Sergio G\u00f3mez]\n| |/  \n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n|/  \n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Volvemos a la rama hola y fusionamos:  $ git checkout hola\nSwitched to branch  hola \n$ git merge master\nAuto-merging lib/hola.php\nCONFLICT (content): Merge conflict in lib/hola.php\nAutomatic merge failed; fix conflicts and then commit the result.  Si editamos nuestro archivo  lib/hola.php  obtendremos algo similar a esto:  ?php  // Autor: Sergio G\u00f3mez  sergio@uco.es    HEAD  // El nombre por defecto es Mundo  require ( HolaMundo.php );  $nombre   =   isset ( $argv [ 1 ])   ?   $argv [ 1 ]   :   Mundo ;  print   new   HolaMundo ( $nombre );  =======  print   Introduce tu nombre: ;  $nombre   =   trim ( fgets ( STDIN ));  @ print   Hola,  { $nombre } \\n ;    master   La primera parte marca el c\u00f3digo que estaba en la rama donde trabaj\u00e1bamos (HEAD) y la parte final el c\u00f3digo de donde fusion\u00e1bamos. Resolvemos el conflicto, dejando el archivo como sigue:  ?php  // Autor: Sergio G\u00f3mez  sergio@uco.es  require ( HolaMundo.php );  print   Introduce tu nombre: ;  $nombre   =   trim ( fgets ( STDIN ));  print   new   HolaMundo ( $nombre );   Y resolvemos el conflicto confirmando los cambios:  $ git add lib/hola.php\n$ git commit -m  Solucionado el conflicto al fusionar con la rama master \n[hola a36af04] Solucionado el conflicto al fusionar con la rama master", 
            "title": "Resolver conflictos"
        }, 
        {
            "location": "/ramas/#rebasing-vs-merging", 
            "text": "Rebasing es otra t\u00e9cnica para fusionar distinta a merge y usa la orden  git rebase . Vamos a dejar nuestro proyecto como estaba antes del fusionado. Para ello necesitamos anotar el hash anterior al de la acci\u00f3n de  merge . El que tiene la anotaci\u00f3n  \"hola usa la clase HolaMundo\" .  Para ello podemos usar la orden  git reset  que nos permite mover HEAD donde queramos.  $ git checkout hola\nSwitched to branch  hola \n$ git hist\n*   a36af04 2013-06-16 | Solucionado el conflicto al fusionar con la rama master (HEAD, hola) [Sergio G\u00f3mez]\n|\\  \n| * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* |   9c6ac06 2013-06-16 | Merge commit  c3e65d0  into hola [Sergio G\u00f3mez]\n|\\ \\  \n| |/  \n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez]\n* | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/  \n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n$ git reset --hard 9862f33\nHEAD is now at 9862f33 hola usa la clase HolaMundo  Y nuestro estado ser\u00e1:  $ git hist --all\n* 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD, hola) [Sergio G\u00f3mez]\n* 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n| * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n|/  \n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Hemos desecho todos los  merge  y nuestro \u00e1rbol est\u00e1  \"limpio\" . Vamos a probar ahora a hacer un rebase. Continuamos en la rama  hola  y ejecutamos lo siguiente:  $ git rebase master\nFirst, rewinding head to replay your work on top of it...\nApplying: A\u00f1adida la clase HolaMundo\nApplying: hola usa la clase HolaMundo\nUsing index info to reconstruct a base tree...\nM   lib/hola.php\nFalling back to patching base and 3-way merge...\nAuto-merging lib/hola.php\nCONFLICT (content): Merge conflict in lib/hola.php\nerror: Failed to merge in the changes.\nPatch failed at 0002 hola usa la clase HolaMundo\nThe copy of the patch that failed is found in: .git/rebase-apply/patch\n\nWhen you have resolved this problem, run  git rebase --continue .\nIf you prefer to skip this patch, run  git rebase --skip  instead.\nTo check out the original branch and stop rebasing, run  git rebase --abort .  El conflicto, por supuesto, se sigue dando. Resolvemos guardando el archivo  hola.php  como en los casos anteriores:  ?php  // Autor: Sergio G\u00f3mez  sergio@uco.es  require ( HolaMundo.php );  print   Introduce tu nombre: ;  $nombre   =   trim ( fgets ( STDIN ));  print   new   HolaMundo ( $nombre );   A\u00f1adimos los cambios en  staging  y en esta ocasi\u00f3n, y tal como nos indicaba en el mensaje anterior, no tenemos que hacer  git commit  sino continuar con el  rebase :  $ git add lib/hola.php\n$ git status\nrebase in progress; onto 269eaca\nYou are currently rebasing branch  hola  on  269eaca .\n  (all conflicts fixed: run  git rebase --continue )\n\nChanges to be committed:\n  (use  git reset HEAD  file ...  to unstage)\n\n    modified:   lib/hola.php\n$ git rebase --continue\nApplying: hola usa la clase HolaMundo  Y ahora vemos que nuestro \u00e1rbol tiene un aspecto distinto, mucho m\u00e1s limpio:  $ git hist --all\n* 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -  hola) [Sergio G\u00f3mez]\n* 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Lo que hace rebase es volver a aplicar todos los cambios a la rama m\u00e1ster, desde su nodo m\u00e1s reciente. Eso significa que se modifica el orden o la historia de creaci\u00f3n de los cambios. Por eso rebase no debe usarse si el orden es importante o si la rama es compartida.", 
            "title": "Rebasing vs Merging"
        }, 
        {
            "location": "/ramas/#mezclando-con-la-rama-master", 
            "text": "Ya hemos terminado de implementar los cambios en nuestra rama secundaria y es hora de llevar los cambios a la rama principal. Usamos  git merge  para hacer una fusi\u00f3n normal:  $ git checkout master\nSwitched to branch  master \n$ git merge hola\nUpdating c3e65d0..491f1d2\nFast-forward\n lib/HolaMundo.php | 16 ++++++++++++++++\n lib/hola.php      |  4 +++-\n 2 files changed, 19 insertions(+), 1 deletion(-)\n create mode 100644 lib/HolaMundo.php\n $ git hist --all\n * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -  master, hola) [Sergio G\u00f3mez]\n * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n * 9c85275 2013-06-16 | Programa interactivo [Sergio G\u00f3mez]\n * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Vemos que indica que el tipo de fusi\u00f3n es  fast-forward . Este tipo de fusi\u00f3n tiene el problema que no deja rastro de la fusi\u00f3n, por eso suele ser recomendable usar el par\u00e1metro   --no-ff  para que quede constancia siempre de que se ha fusionado una rama con otra.  Vamos a volver a probar ahora sin hacer  fast-forward . Reseteamos  master  al estado  \"Programa interactivo\" .  $ git reset --hard 9c85275\n$ git hist --all\n* 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -  hola) [Sergio G\u00f3mez]\n* 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Vemos que estamos como en el final de la secci\u00f3n anterior, as\u00ed que ahora mezclamos:  $ git merge -m  Aplicando los cambios de la rama hola  --no-ff hola\nMerge made by the  recursive  strategy.\n lib/HolaMundo.php | 16 ++++++++++++++++\n lib/hola.php      |  4 +++-\n 2 files changed, 19 insertions(+), 1 deletion(-)\n create mode 100644 lib/HolaMundo.php\n$ git hist --all\n*   2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (HEAD -  master) [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  En la siguiente imagen se puede ver la diferencia:", 
            "title": "Mezclando con la rama master"
        }, 
        {
            "location": "/github/", 
            "text": "Github\n\n\nGithub es lo que se denomina una forja, un repositorio de proyectos que usan Git como sistema de control de versiones. Es la forja m\u00e1s popular, ya que alberga m\u00e1s de 10 millones de repositorios. Debe su popularidad a sus funcionalidades sociales, principalmente dos: la posibilidad de hacer forks de otros proyectos y la posibilidad de cooperar aportando c\u00f3digo para arreglar errores o mejorar el c\u00f3digo. Si bien, no es que fuera una novedad, s\u00ed lo es lo f\u00e1cil que resulta hacerlo. A ra\u00edz de este proyecto han surgido otros como \nGitorius\n o \nGitlab\n, pero \nGithub\n sigue siendo el m\u00e1s popular y el que tiene mejores y mayores caracter\u00edsticas. algunas de estas son:\n\n\n\n\nUn wiki para documentar el proyecto, que usa MarkDown como lenguaje de marca.\n\n\nUn portal web para cada proyecto.\n\n\nFuncionalidades de redes sociales como followers.\n\n\nGr\u00e1ficos estad\u00edsticos.\n\n\nRevisi\u00f3n de c\u00f3digo y comentarios.\n\n\nSistemas de seguimiento de incidencias.\n\n\n\n\nLo primero es entrar en el portal (\nhttps://github.com/\n) para crearnos una cuenta si no la tenemos a\u00fan.\n\n\nConfiguraci\u00f3n\n\n\nVamos a aprovechar para a\u00f1adir la clave RSA que generamos antes, para poder acceder desde git a los repositorios. Para ellos nos vamos al men\u00fa de configuraci\u00f3n de usuario (\nSettings\n)\n\n\n\n\nNos vamos al men\u00fa 'SSH and GPG Keys' y a\u00f1adimos una nueva clave. En \nTitle\n indicamos una descripci\u00f3n que nos ayude a saber de d\u00f3nde procede la clave y en key volcamos el contenido del archivo \n~/.ssh/id_rsa.pub\n. Y guardamos la clave.\n\n\n\n\nCon esto ya tendriamos todo nuestro entorno para poder empezar a trabajar desde nuestro equipo.\n\n\nClientes gr\u00e1ficos para GitHub\n\n\nAdem\u00e1s, para Github existe un cliente propio tanto para Windows como para MacOSX:\n\n\n\n\n\n\nCliente Windows: \nhttp://windows.github.com/\n\n\n\n\n\n\nCliente MacOSX: \nhttp://mac.github.com/\n\n\n\n\n\n\nPara Linux no hay cliente propio, pero s\u00ed hay plugin para la mayor\u00eda de editores de texto como atom, netbeans, eclipe o los editores de jetbrains.\n\n\nDe todas maneras, estos clientes solo tienen el fin de facilitar el uso de Github, pero no son necesarios para usarlo. Es perfectamente v\u00e1lido usar el cliente de consola de Git o cualquier otro cliente gen\u00e9rico para Git. Uno de los m\u00e1s usados actualmente es \nGitKraken\n.\n\n\nCrear un repositorio\n\n\nVamos a crear un repositorio donde guardar nuestro proyecto. Para ello pulsamos el signo \n+\n que hay en la barra superior y seleccionamos \nNew repository\n.\n\n\nAhora tenemos que designar un nombre para nuestro repositorio, por ejemplo: '\ntaller-de-git\n'.\n\n\n\n\nNada m\u00e1s crear el repositorio nos saldr\u00e1 una pantalla con instrucciones precisas de como proceder a continuaci\u00f3n.\n\n\nB\u00e1sicamente podemos partir de tres situaciones:\n\n\n\n\nTodav\u00eda no hemos creado ning\u00fan repositorio en nuestro equipo.\n\n\nYa tenemos un repositorio creado y queremos sincronizarlo con Github.\n\n\nQueremos importar un repositorio de otro sistema de control de versiones distinto.\n\n\n\n\n\n\nNuestra situaci\u00f3n es la segunda, as\u00ed que nos aseguramos de que hemos elegido SSH como protocolo. A continuaci\u00f3n pulsamos el icono del portapapeles y ejecutamos las dos ordenes que nos indica la web en nuestro terminal.\n\n\n$ git remote add origin git@github.com:sgomez/taller-de-git.git\n$ git push -u origin master\nCounting objects: 33, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (24/24), done.\nWriting objects: 100% (33/33), 3.35 KiB | 1.12 MiB/s, done.\nTotal 33 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), done.\nTo github.com:sgomez/taller-de-git.git\n * [new branch]      master -\n master\nBranch master set up to track remote branch master from origin by rebasing.\n\n\n\n\n\nSi recargamos la p\u00e1gina veremos que ya aparece nuestro proyecto.\n\n\n\n\nClonar un repositorio\n\n\nUna vez que ya tengamos sincronizado el repositorio contra Github, eventualmente\nvamos a querer descargarlo en otro de nuestros ordenadores para poder trabajar\nen \u00e9l. Esta acci\u00f3n se denomina clonar y para ello usaremos la orden \ngit clone\n.\n\n\nEn la p\u00e1gina principal de nuestro proyecto podemos ver un bot\u00f3n que indica \nClone or download\n.\nSi la pulsamos nos da, de nuevo, la opci\u00f3n de elegir entre clonar con \nssh\n o \nhttps\n.\nRecordad que si est\u00e1is en otro equipo y quer\u00e9is seguir utilizando ssh deber\u00e9is\ngenerar otra para de claves privada/p\u00fablica como hicimos en la secci\u00f3n de\n\nAspectos b\u00e1sicos de Git\n y instalarla\nen nuestro perfil de Github, como vimos anteriormente.\n\n\nPara clonar nuestro repositorio y poder trabajar con \u00e9l todo lo que debemos hacer es\nlo siguiente:\n\n\n$ git clone git@github.com:sgomez/taller-de-git.git\n$ cd taller-de-git\n\n\n\n\n\nRamas remotas\n\n\nSi ahora vemos el estado de nuestro proyecto veremos algo similar a esto:\n\n\n$ git hist --all\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (HEAD -\n master, origin/master) [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nAparece que hay una nueva rama llamada \norigin/master\n. Esta rama indica el estado de sincronizaci\u00f3n\nde nuestro repositorio con un repositorio remoto llamado \norigin\n. En este caso el de \nGithub\n.\n\n\n\n\nInfo\n\n\nPor norma se llama autom\u00e1ticamente \norigin\n al primer repositorio con el que\nsincronizamos nuestro repositorio.\n\n\n\n\nPodemos ver la configuraci\u00f3n de este repositorio remoto con la orden \ngit remote\n:\n\n\n$ git remote show origin\n* remote origin\n  Fetch URL: git@github.com:sgomez/taller-de-git.git\n  Push  URL: git@github.com:sgomez/taller-de-git.git\n  HEAD branch: master\n  Remote branch:\n    master tracked\n  Local ref configured for \ngit push\n:\n    master pushes to master (up to date)\n\n\n\n\n\nDe la respuesta tenemos que fijarnos en las l\u00edneas que indican \nfetch\n y \npush\n\npuesto que son las acciones de sincronizaci\u00f3n de nuestro repositorio con el remoto.\nMientras que \nfetch\n se encarga de traer los cambios desde el repositorio remoto\nal nuestro, \npush\n los env\u00eda.\n\n\nEnviando actualizaciones\n\n\nVamos a a\u00f1adir una licencia a nuestra aplicaci\u00f3n. Creamos un fichero LICENSE con el siguiente contenido:\n\n\nMIT License\n\nCopyright (c) [year] [fullname]\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \nSoftware\n), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\n\n\n\nY a\u00f1adidos y confirmamos los cambios:\n\n\n$ git add LICENSE\n$ git commit -m \nA\u00f1adida licencia\n\n[master 3f5cb1c] A\u00f1adida licencia\n 1 file changed, 21 insertions(+)\n create mode 100644 LICENSE\n$ git hist --all\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia (HEAD -\n master) [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (origin/master) [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nViendo la historia podemos ver como nuestro master no est\u00e1 en el mismo punto que\n\norigin/master\n. Si vamos a la web de \nGithub\n veremos que \nLICENSE\n no aparece a\u00fan.\nAs\u00ed que vamos a enviar los cambios con la primera de las acciones que vimos \ngit push\n:\n\n\n$ git push -u origin master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 941 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo git@github.com:sgomez/taller-de-git.git\n   2eab8ca..3f5cb1c  master -\n master\nBranch master set up to track remote branch master from origin.\n\n\n\n\n\n\n\nInfo\n\n\nLa orden \ngit push\n necesita dos par\u00e1metros para funcionar: el repositorio\ny la rama destino. As\u00ed que realmente lo que ten\u00edamos que haber escrito es:\n\n\n$ git push origin master\n\n\n\n\n\nPara ahorrar tiempo escribiendo \ngit\n nos deja vincular nuestra rama local\ncon una rama remota, de tal manera que no tengamos que estar siempre indic\u00e1ndolo.\nEso es posible con el par\u00e1metro \n--set-upstream\n o \n-u\n en forma abreviada.\n\n\n$ git push -u origin master\n\n\n\n\n\nSi repasas las \u00f3rdenes que te indic\u00f3 Github que ejecutaras ver\u00e1s que el par\u00e1metro\n\n-u\n estaba presente y por eso no ha sido necesario indicar ning\u00fan par\u00e1metro\nal hacer push.\n\n\n\n\nRecibiendo actualizaciones\n\n\nSi trabajamos con m\u00e1s personas, o trabajamos desde dos ordenadores distintos, nos encontraremos\ncon que nuestro repositorio local es m\u00e1s antiguo que el remoto. Necesitamos descargar\nlos cambios para poder incorporarlos a nuestro directorio de trabajo.\n\n\nPara la prueba, Github nos permite editar archivos directamente desde la web. Pulsamos sobre\nel archivo \nREADME.md\n. En la vista del archivo, veremos que aparece el icono de un l\u00e1piz.\nEsto nos permite editar el archivo.\n\n\n\n\n\n\nInfo\n\n\nLos archivos con extensi\u00f3n \n.md\n est\u00e1n en un formato denominado \nMarkDown\n. Se trata\nde un lenguaje de marca que nos permite escribir texto enriquecido de manera muy sencilla.\n\n\nDispones de un tutorial aqu\u00ed: \nhttps://www.markdowntutorial.com/\n\n\n\n\nModificamos el archivo como queramos, por ejemplo, a\u00f1adiendo nuestro nombre:\n\n\n# Curso de GIT\n\nEste proyecto contiene el curso de introducci\u00f3n a GIT\n\nDesarrollado por Sergio G\u00f3mez.\n\n\n\n\n\n\n\nEl cambio quedar\u00e1 incorporado al repositorio de Github, pero no al nuestro. Necesitamos\ntraer la informaci\u00f3n desde el servidor remoto. La orden asociada es \ngit fetch\n:\n\n\n$ git fetch\n$ git hist --all\n* cbaf831 2013-06-16 | Actualizado README.md (origin/master) [Sergio G\u00f3mez]\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia (HEAD -\n master) [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nAhora vemos el caso contrario, tenemos que \norigin/master\n est\u00e1 por delante que \nHEAD\n y\nque la rama \nmaster\n local.\n\n\nAhora necesitamos incorporar los cambios de la rama remota en la local. La forma de hacerlo\nlo vimos en el \ncap\u00edtulo anterior\n usando \ngit merge\n o \ngit rebase\n.\n\n\nHabitualmente se usa \ngit merge\n:\n\n\n$ git merge origin/master\nUpdating 3f5cb1c..cbaf831\nFast-forward\n README.md | 2 ++\n 1 file changed, 2 insertions(+)\n$ git hist --all\n* cbaf831 2013-06-16 | Actualizado README.md (HEAD -\n master, origin/master) [Sergio G\u00f3mez]\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nComo las operaciones de traer cambios (\ngit fetch\n) y de mezclar ramas (\ngit merge\n o \ngit rebase\n)\nest\u00e1n muy asociadas, \ngit\n nos ofrece una posibilidad para ahorrar pasos que es la orden \ngit push\n\nque realiza las dos acciones simult\u00e1neamente.\n\n\nPara probar, vamos a editar de nuevo el archivo README.md y a\u00f1adimos algo m\u00e1s:\n\n\n# Curso de GIT\n\nEste proyecto contiene el curso de introducci\u00f3n a GIT del Aula de Software Libre.\n\nDesarrollado por Sergio G\u00f3mez.\n\n\n\n\n\nComo mensaje del \ncommit\n: \n'Indicado que se realiza en el ASL'\n.\n\n\nY ahora probamos a actualizar con \ngit pull\n:\n\n\n$ git pull\nremote: Counting objects: 3, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), done.\nFrom github.com:sgomez/taller-de-git\n   cbaf831..d8922e4  master     -\n origin/master\nFirst, rewinding head to replay your work on top of it...\nFast-forwarded master to d8922e4ffa4f87553b03e77df6196b7e496bfec4.\n$ git hist --all\n* d8922e4 2013-06-16 | Indicado que se realiza en el ASL (HEAD -\n master, origin/master) [Sergio G\u00f3mez]\n* cbaf831 2013-06-16 | Actualizado README.md [Sergio G\u00f3mez]\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n\n\n\n\n\nVemos que los cambios se han incorporado y que las ramas remota y local de \nmaster\n est\u00e1n\nsincronizadas.\n\n\nProblemas de sincronizaci\u00f3n\n\n\nNo puedo hacer push\n\n\nAl intentar subir cambios nos podemos encontrar un mensaje como este:\n\n\n$ git push\ngit push\nTo git@github.com:sgomez/taller-de-git.git\n ! [rejected]        master -\n master (fetch first)\nerror: failed to push some refs to \ngit@github.com:sgomez/taller-de-git.git\n\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., \ngit pull ...\n) before pushing again.\nhint: See the \nNote about fast-forwards\n in \ngit push --help\n for details.\n\n\n\n\n\nLa causa es que el repositorio remoto tambi\u00e9n se ha actualizado y nosotros a\u00fan\nno hemos recibido esos cambios. Es decir, ambos repositorios se han actualizado\ny el remoto tiene preferencia. Hay un conflicto en ciernes y se debe resolver\nlocalmente antes de continuar.\n\n\nLa forma de proceder en este caso es hacer un \ngit fetch\n y un \ngit rebase\n. Si\nhay conflictos deber\u00e1n resolverse. Cuando est\u00e9 todo solucionado ya podremos hacer\n\ngit push\n.\n\n\n\n\nInfo\n\n\nPor defecto \ngit pull\n lo que hace es un \ngit merge\n, si queremos hacer\n\ngit rebase\n deberemos especificarlos con el par\u00e1metro \n-r\n:\n\n\n$ git pull -r\n\n\n\n\n\n\n\nNo puedo hacer pull\n\n\nAl intentar descargar cambios nos podemos encontrar un mensaje como este:\n\n\n$ git pull\nerror: Cannot pull with rebase: You have unstaged changes.\n\n\n\n\n\nO como este:\n\n\n$ git pull\nerror: Cannot pull with rebase: Your index contains uncommitted changes.\n\n\n\n\n\nB\u00e1sicamente lo que ocurre es que tenemos cambios sin confirmar en nuestro espacio\nde trabajo. Una opci\u00f3n es confirmar (\ncommit\n) y entonces proceder como el caso anterior.\n\n\nPero puede ocurrir que a\u00fan estemos trabajando todav\u00eda y no nos interese confirmar\nlos cambios, solo queremos sincronizar y seguir trabajando. Para casos como estos\n\ngit\n ofrece una pila para guardar cambios temporalmente. Esta pila se llama \nstash\n\ny nos permite restaurar el espacio de trabajo al \u00faltimo commit.\n\n\nLa forma de proceder es la siguiente:\n\n\n$ git stash save # Guardamos los cambios en la pila\n$ git pull # Sincronizamos con el repositorio remoto\n$ git stash pop # Sacamos los cambios de la pila\n\n\n\n\n\nPodr\u00eda darse el caso de que al sacar los cambios de la pila hubiera alg\u00fan\nconflicto. En ese caso actuamos como con el caso de \nmerge\n o \nrebase\n.", 
            "title": "Github"
        }, 
        {
            "location": "/github/#github", 
            "text": "Github es lo que se denomina una forja, un repositorio de proyectos que usan Git como sistema de control de versiones. Es la forja m\u00e1s popular, ya que alberga m\u00e1s de 10 millones de repositorios. Debe su popularidad a sus funcionalidades sociales, principalmente dos: la posibilidad de hacer forks de otros proyectos y la posibilidad de cooperar aportando c\u00f3digo para arreglar errores o mejorar el c\u00f3digo. Si bien, no es que fuera una novedad, s\u00ed lo es lo f\u00e1cil que resulta hacerlo. A ra\u00edz de este proyecto han surgido otros como  Gitorius  o  Gitlab , pero  Github  sigue siendo el m\u00e1s popular y el que tiene mejores y mayores caracter\u00edsticas. algunas de estas son:   Un wiki para documentar el proyecto, que usa MarkDown como lenguaje de marca.  Un portal web para cada proyecto.  Funcionalidades de redes sociales como followers.  Gr\u00e1ficos estad\u00edsticos.  Revisi\u00f3n de c\u00f3digo y comentarios.  Sistemas de seguimiento de incidencias.   Lo primero es entrar en el portal ( https://github.com/ ) para crearnos una cuenta si no la tenemos a\u00fan.", 
            "title": "Github"
        }, 
        {
            "location": "/github/#configuracion", 
            "text": "Vamos a aprovechar para a\u00f1adir la clave RSA que generamos antes, para poder acceder desde git a los repositorios. Para ellos nos vamos al men\u00fa de configuraci\u00f3n de usuario ( Settings )   Nos vamos al men\u00fa 'SSH and GPG Keys' y a\u00f1adimos una nueva clave. En  Title  indicamos una descripci\u00f3n que nos ayude a saber de d\u00f3nde procede la clave y en key volcamos el contenido del archivo  ~/.ssh/id_rsa.pub . Y guardamos la clave.   Con esto ya tendriamos todo nuestro entorno para poder empezar a trabajar desde nuestro equipo.", 
            "title": "Configuraci\u00f3n"
        }, 
        {
            "location": "/github/#clientes-graficos-para-github", 
            "text": "Adem\u00e1s, para Github existe un cliente propio tanto para Windows como para MacOSX:    Cliente Windows:  http://windows.github.com/    Cliente MacOSX:  http://mac.github.com/    Para Linux no hay cliente propio, pero s\u00ed hay plugin para la mayor\u00eda de editores de texto como atom, netbeans, eclipe o los editores de jetbrains.  De todas maneras, estos clientes solo tienen el fin de facilitar el uso de Github, pero no son necesarios para usarlo. Es perfectamente v\u00e1lido usar el cliente de consola de Git o cualquier otro cliente gen\u00e9rico para Git. Uno de los m\u00e1s usados actualmente es  GitKraken .", 
            "title": "Clientes gr\u00e1ficos para GitHub"
        }, 
        {
            "location": "/github/#crear-un-repositorio", 
            "text": "Vamos a crear un repositorio donde guardar nuestro proyecto. Para ello pulsamos el signo  +  que hay en la barra superior y seleccionamos  New repository .  Ahora tenemos que designar un nombre para nuestro repositorio, por ejemplo: ' taller-de-git '.   Nada m\u00e1s crear el repositorio nos saldr\u00e1 una pantalla con instrucciones precisas de como proceder a continuaci\u00f3n.  B\u00e1sicamente podemos partir de tres situaciones:   Todav\u00eda no hemos creado ning\u00fan repositorio en nuestro equipo.  Ya tenemos un repositorio creado y queremos sincronizarlo con Github.  Queremos importar un repositorio de otro sistema de control de versiones distinto.    Nuestra situaci\u00f3n es la segunda, as\u00ed que nos aseguramos de que hemos elegido SSH como protocolo. A continuaci\u00f3n pulsamos el icono del portapapeles y ejecutamos las dos ordenes que nos indica la web en nuestro terminal.  $ git remote add origin git@github.com:sgomez/taller-de-git.git\n$ git push -u origin master\nCounting objects: 33, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (24/24), done.\nWriting objects: 100% (33/33), 3.35 KiB | 1.12 MiB/s, done.\nTotal 33 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), done.\nTo github.com:sgomez/taller-de-git.git\n * [new branch]      master -  master\nBranch master set up to track remote branch master from origin by rebasing.  Si recargamos la p\u00e1gina veremos que ya aparece nuestro proyecto.", 
            "title": "Crear un repositorio"
        }, 
        {
            "location": "/github/#clonar-un-repositorio", 
            "text": "Una vez que ya tengamos sincronizado el repositorio contra Github, eventualmente\nvamos a querer descargarlo en otro de nuestros ordenadores para poder trabajar\nen \u00e9l. Esta acci\u00f3n se denomina clonar y para ello usaremos la orden  git clone .  En la p\u00e1gina principal de nuestro proyecto podemos ver un bot\u00f3n que indica  Clone or download .\nSi la pulsamos nos da, de nuevo, la opci\u00f3n de elegir entre clonar con  ssh  o  https .\nRecordad que si est\u00e1is en otro equipo y quer\u00e9is seguir utilizando ssh deber\u00e9is\ngenerar otra para de claves privada/p\u00fablica como hicimos en la secci\u00f3n de Aspectos b\u00e1sicos de Git  y instalarla\nen nuestro perfil de Github, como vimos anteriormente.  Para clonar nuestro repositorio y poder trabajar con \u00e9l todo lo que debemos hacer es\nlo siguiente:  $ git clone git@github.com:sgomez/taller-de-git.git\n$ cd taller-de-git", 
            "title": "Clonar un repositorio"
        }, 
        {
            "location": "/github/#ramas-remotas", 
            "text": "Si ahora vemos el estado de nuestro proyecto veremos algo similar a esto:  $ git hist --all\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (HEAD -  master, origin/master) [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Aparece que hay una nueva rama llamada  origin/master . Esta rama indica el estado de sincronizaci\u00f3n\nde nuestro repositorio con un repositorio remoto llamado  origin . En este caso el de  Github .   Info  Por norma se llama autom\u00e1ticamente  origin  al primer repositorio con el que\nsincronizamos nuestro repositorio.   Podemos ver la configuraci\u00f3n de este repositorio remoto con la orden  git remote :  $ git remote show origin\n* remote origin\n  Fetch URL: git@github.com:sgomez/taller-de-git.git\n  Push  URL: git@github.com:sgomez/taller-de-git.git\n  HEAD branch: master\n  Remote branch:\n    master tracked\n  Local ref configured for  git push :\n    master pushes to master (up to date)  De la respuesta tenemos que fijarnos en las l\u00edneas que indican  fetch  y  push \npuesto que son las acciones de sincronizaci\u00f3n de nuestro repositorio con el remoto.\nMientras que  fetch  se encarga de traer los cambios desde el repositorio remoto\nal nuestro,  push  los env\u00eda.", 
            "title": "Ramas remotas"
        }, 
        {
            "location": "/github/#enviando-actualizaciones", 
            "text": "Vamos a a\u00f1adir una licencia a nuestra aplicaci\u00f3n. Creamos un fichero LICENSE con el siguiente contenido:  MIT License\n\nCopyright (c) [year] [fullname]\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the  Software ), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED  AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.  Y a\u00f1adidos y confirmamos los cambios:  $ git add LICENSE\n$ git commit -m  A\u00f1adida licencia \n[master 3f5cb1c] A\u00f1adida licencia\n 1 file changed, 21 insertions(+)\n create mode 100644 LICENSE\n$ git hist --all\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia (HEAD -  master) [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (origin/master) [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Viendo la historia podemos ver como nuestro master no est\u00e1 en el mismo punto que origin/master . Si vamos a la web de  Github  veremos que  LICENSE  no aparece a\u00fan.\nAs\u00ed que vamos a enviar los cambios con la primera de las acciones que vimos  git push :  $ git push -u origin master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 941 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo git@github.com:sgomez/taller-de-git.git\n   2eab8ca..3f5cb1c  master -  master\nBranch master set up to track remote branch master from origin.   Info  La orden  git push  necesita dos par\u00e1metros para funcionar: el repositorio\ny la rama destino. As\u00ed que realmente lo que ten\u00edamos que haber escrito es:  $ git push origin master  Para ahorrar tiempo escribiendo  git  nos deja vincular nuestra rama local\ncon una rama remota, de tal manera que no tengamos que estar siempre indic\u00e1ndolo.\nEso es posible con el par\u00e1metro  --set-upstream  o  -u  en forma abreviada.  $ git push -u origin master  Si repasas las \u00f3rdenes que te indic\u00f3 Github que ejecutaras ver\u00e1s que el par\u00e1metro -u  estaba presente y por eso no ha sido necesario indicar ning\u00fan par\u00e1metro\nal hacer push.", 
            "title": "Enviando actualizaciones"
        }, 
        {
            "location": "/github/#recibiendo-actualizaciones", 
            "text": "Si trabajamos con m\u00e1s personas, o trabajamos desde dos ordenadores distintos, nos encontraremos\ncon que nuestro repositorio local es m\u00e1s antiguo que el remoto. Necesitamos descargar\nlos cambios para poder incorporarlos a nuestro directorio de trabajo.  Para la prueba, Github nos permite editar archivos directamente desde la web. Pulsamos sobre\nel archivo  README.md . En la vista del archivo, veremos que aparece el icono de un l\u00e1piz.\nEsto nos permite editar el archivo.    Info  Los archivos con extensi\u00f3n  .md  est\u00e1n en un formato denominado  MarkDown . Se trata\nde un lenguaje de marca que nos permite escribir texto enriquecido de manera muy sencilla.  Dispones de un tutorial aqu\u00ed:  https://www.markdowntutorial.com/   Modificamos el archivo como queramos, por ejemplo, a\u00f1adiendo nuestro nombre:  # Curso de GIT\n\nEste proyecto contiene el curso de introducci\u00f3n a GIT\n\nDesarrollado por Sergio G\u00f3mez.   El cambio quedar\u00e1 incorporado al repositorio de Github, pero no al nuestro. Necesitamos\ntraer la informaci\u00f3n desde el servidor remoto. La orden asociada es  git fetch :  $ git fetch\n$ git hist --all\n* cbaf831 2013-06-16 | Actualizado README.md (origin/master) [Sergio G\u00f3mez]\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia (HEAD -  master) [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Ahora vemos el caso contrario, tenemos que  origin/master  est\u00e1 por delante que  HEAD  y\nque la rama  master  local.  Ahora necesitamos incorporar los cambios de la rama remota en la local. La forma de hacerlo\nlo vimos en el  cap\u00edtulo anterior  usando  git merge  o  git rebase .  Habitualmente se usa  git merge :  $ git merge origin/master\nUpdating 3f5cb1c..cbaf831\nFast-forward\n README.md | 2 ++\n 1 file changed, 2 insertions(+)\n$ git hist --all\n* cbaf831 2013-06-16 | Actualizado README.md (HEAD -  master, origin/master) [Sergio G\u00f3mez]\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Como las operaciones de traer cambios ( git fetch ) y de mezclar ramas ( git merge  o  git rebase )\nest\u00e1n muy asociadas,  git  nos ofrece una posibilidad para ahorrar pasos que es la orden  git push \nque realiza las dos acciones simult\u00e1neamente.  Para probar, vamos a editar de nuevo el archivo README.md y a\u00f1adimos algo m\u00e1s:  # Curso de GIT\n\nEste proyecto contiene el curso de introducci\u00f3n a GIT del Aula de Software Libre.\n\nDesarrollado por Sergio G\u00f3mez.  Como mensaje del  commit :  'Indicado que se realiza en el ASL' .  Y ahora probamos a actualizar con  git pull :  $ git pull\nremote: Counting objects: 3, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), done.\nFrom github.com:sgomez/taller-de-git\n   cbaf831..d8922e4  master     -  origin/master\nFirst, rewinding head to replay your work on top of it...\nFast-forwarded master to d8922e4ffa4f87553b03e77df6196b7e496bfec4.\n$ git hist --all\n* d8922e4 2013-06-16 | Indicado que se realiza en el ASL (HEAD -  master, origin/master) [Sergio G\u00f3mez]\n* cbaf831 2013-06-16 | Actualizado README.md [Sergio G\u00f3mez]\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]  Vemos que los cambios se han incorporado y que las ramas remota y local de  master  est\u00e1n\nsincronizadas.", 
            "title": "Recibiendo actualizaciones"
        }, 
        {
            "location": "/github/#problemas-de-sincronizacion", 
            "text": "", 
            "title": "Problemas de sincronizaci\u00f3n"
        }, 
        {
            "location": "/github/#no-puedo-hacer-push", 
            "text": "Al intentar subir cambios nos podemos encontrar un mensaje como este:  $ git push\ngit push\nTo git@github.com:sgomez/taller-de-git.git\n ! [rejected]        master -  master (fetch first)\nerror: failed to push some refs to  git@github.com:sgomez/taller-de-git.git \nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g.,  git pull ... ) before pushing again.\nhint: See the  Note about fast-forwards  in  git push --help  for details.  La causa es que el repositorio remoto tambi\u00e9n se ha actualizado y nosotros a\u00fan\nno hemos recibido esos cambios. Es decir, ambos repositorios se han actualizado\ny el remoto tiene preferencia. Hay un conflicto en ciernes y se debe resolver\nlocalmente antes de continuar.  La forma de proceder en este caso es hacer un  git fetch  y un  git rebase . Si\nhay conflictos deber\u00e1n resolverse. Cuando est\u00e9 todo solucionado ya podremos hacer git push .   Info  Por defecto  git pull  lo que hace es un  git merge , si queremos hacer git rebase  deberemos especificarlos con el par\u00e1metro  -r :  $ git pull -r", 
            "title": "No puedo hacer push"
        }, 
        {
            "location": "/github/#no-puedo-hacer-pull", 
            "text": "Al intentar descargar cambios nos podemos encontrar un mensaje como este:  $ git pull\nerror: Cannot pull with rebase: You have unstaged changes.  O como este:  $ git pull\nerror: Cannot pull with rebase: Your index contains uncommitted changes.  B\u00e1sicamente lo que ocurre es que tenemos cambios sin confirmar en nuestro espacio\nde trabajo. Una opci\u00f3n es confirmar ( commit ) y entonces proceder como el caso anterior.  Pero puede ocurrir que a\u00fan estemos trabajando todav\u00eda y no nos interese confirmar\nlos cambios, solo queremos sincronizar y seguir trabajando. Para casos como estos git  ofrece una pila para guardar cambios temporalmente. Esta pila se llama  stash \ny nos permite restaurar el espacio de trabajo al \u00faltimo commit.  La forma de proceder es la siguiente:  $ git stash save # Guardamos los cambios en la pila\n$ git pull # Sincronizamos con el repositorio remoto\n$ git stash pop # Sacamos los cambios de la pila  Podr\u00eda darse el caso de que al sacar los cambios de la pila hubiera alg\u00fan\nconflicto. En ese caso actuamos como con el caso de  merge  o  rebase .", 
            "title": "No puedo hacer pull"
        }, 
        {
            "location": "/github-avanzado/", 
            "text": "Github avanzado\n\n\nEsta secci\u00f3n trata de c\u00f3mo colaborar con proyectos de terceros.\n\n\nClonar un repositorio\n\n\nNos vamos a la web del proyecto en el que queremos colaborar. En este caso el proyecto se encuentra en \nhttps://github.com/sgomez/miniblog\n. Pulsamos en el bot\u00f3n de fork y eso crear\u00e1 una copia en nuestro perfil.\n\n\n\n\nUna vez se termine de clonar el repositorio, nos encontraremos con el espacio de trabajo del mismo:\n\n\n\n\nEn la parte superior informaci\u00f3n sobre los commits, ramas, etiquetas, etc.\n\n\nJusto debajo un explorador de archivos.\n\n\nEn la parte derecha un selector para cambiar de contexto entre: explorador de c\u00f3digo, peticiones de colaboraci\u00f3n (pull request), wiki, configuraci\u00f3n, etc.\n\n\nJusto abajo a la derecha informaci\u00f3n sobre como clonar localmente o descargar un proyecto.\n\n\n\n\n\n\nGithub nos permite clonar localmente un proyecto por tres v\u00edas: HTTPS, SSH y Subversion. Seleccionamos SSH y copiamos el texto que despu\u00e9s a\u00f1adiremos a la orden \ngit clone\n como en la primera l\u00ednea del siguiente grupo de \u00f3rdenes:\n\n\n$ git clone git@github.com:miusuario/miniblog.git\n$ cd miniblog\n$ composer.phar install\n$ php console create-schema\n\n\n\n\n\nLo que hace el c\u00f3digo anterior es:\n\n\n\n\nClona el repositorio localmente\n\n\nEntramos en la copia\n\n\nInstalamos las dependencias que la aplicaci\u00f3n tiene\n\n\nArrancamos un servidor web para pruebas\n\n\n\n\nY probamos que nuestra aplicaci\u00f3n funciona:\n\n\n$ php -S localhost:9999 -t web/\n\n\n\n\n\nPodemos usar dos direcciones para probarla:\n\n\n\n\nFrontend: \nhttp://localhost:9999/index_dev.php\n\n\nBackend: \nhttp://localhost:9999/index_dev.php/admin/\n con usuario admin y contrase\u00f1a 1234.\n\n\n\n\nSincronizar con el repositorio original\n\n\nCuando clonamos un repositorio de otro usuario hacemos una copia del original. Pero esa copia es igual al momento en el que hicimos la copia. Cuando el repositorio original cambie, que lo har\u00e1, nuestro repositorio no se actualizar\u00e1 solo. \u00a1Son dos repositorios diferentes! Necesitamos una manera de poder incorporar los cambios que vaya teniendo el repositorio original en el nuestro. Para eso crearemos una nueva rama remota. Por convenio, y como vimos anteriormente, ya existe una rama remota llamada \norigin\n que apunta al repositorio de donde clonamos el proyecto, en este caso apunta a nuestro fork en github:\n\n\n$ git remote show origin\n* remote origin\n  Fetch URL: git@github.com:miusuario/miniblog.git\n  Push  URL: git@github.com:miusuario/miniblog.git\n  HEAD branch (remote HEAD is ambiguous, may be one of the following):\n    develop\n    master\n  Remote branches:\n    develop tracked\n    master  tracked\n  Local branch configured for \ngit pull\n:\n    master merges with remote master\n  Local ref configured for \ngit push\n:\n    master pushes to master (up to date)\n\n\n\n\n\nTambi\u00e9n por convenio, la rama remota que hace referencia al repositorio original se llama \nupstream\n y se crea de la siguiente manera:\n\n\n$ git remote add upstream git@github.com:sgomez/miniblog.git\n$ git remote show upstream\n* remote upstream\n  Fetch URL: git@github.com:sgomez/miniblog.git\n  Push  URL: git@github.com:sgomez/miniblog.git\n  HEAD branch: master\n  Remote branches:\n    develop new (next fetch will store in remotes/upstream)\n    master  new (next fetch will store in remotes/upstream)\n  Local ref configured for \ngit push\n:\n    master pushes to master (local out of date)\n\n\n\n\n\nEn este caso, la URI debe ser siempre la del proyecto original. Y ahora para incorporar actualizaciones, usaremos el merge en dos pasos:\n\n\n$ git fetch upstream\n$ git merge upstream/master\n\n\n\n\n\nRecordemos que \nfetch\n solo trae los cambios que existan en el repositorio remoto sin hacer ning\u00fan cambio en nuestro repositorio. Es la orden \nmerge\n la que se encarga de que todo est\u00e9 sincronizado. En este caso decimos que queremos fusionar con la rama \nmaster\n que est\u00e1 en el repositorio \nupstream\n.\n\n\nCreando nuevas funcionalidades\n\n\nVamos a crear una nueva funcionalidad: vamos a a\u00f1adir una licencia de uso. Para ello preferentemente crearemos una nueva rama.\n\n\n$ git checkout -b add-license\n$ echo \nLICENCIA MIT\n \n LICESE\n#\u00a0el error es intencionado\n$ git add LICESE\n$ git commit -m \nArchivo de licencia de uso\n\n\n\n\n\n\nEn principio habr\u00eda que probar que todo funciona bien y entonces integraremos en la rama \nmaster\n de nuestro repositorio y enviamos los cambios a Github:\n\n\n$ git checkout master\n$ git merge add-license --no-ff\n$ git branch -d add-license\n# Borramos la rama que ya no nos sirve para nada\n$ git push --set-upstream origin add-license\n# Enviamos la rama a nuestro repositorio origin\n\n\n\n\n\nSi volvemos a Github, veremos que nos avisa de que hemos subido una nueva rama y si queremos crear un pull request.\n\n\n\n\nPulsamos y entramos en la petici\u00f3n de \nPull Request\n. Este es el momento para revisar cualquier error antes de enviar al due\u00f1o del repositorio. Como vemos hemos cometido uno, nombrando el fichero, si lo correguimos debemos hacer otro push para ir actualizando la rama. Cuando est\u00e9 lista volvemos aqu\u00ed y continuamos. Hay que dejar una descripci\u00f3n del cambio que vamos a hacer.\n\n\n\n\nUna vez hemos terminado y nos aseguramos que todo est\u00e1 correcto, pulsamos \nSend pull request\n y le llegar\u00e1 nuestra petici\u00f3n al due\u00f1o del proyecto.\n\n\n\n\nSin embargo, para esta prueba, no vamos a cambiar el nombre del archivo y dejaremos el error como est\u00e1. As\u00ed de esta manera al administrador del proyecto le llegar\u00e1 el \nPull Request\n y la lista de cambios. Ahora en principio, cabr\u00eda esperar que el administrador aprobara los cambios, pero podr\u00eda pasar que nos indicara que cambiemos algo. En ese caso solo habr\u00eda que modificar la rama y volverla a enviar.\n\n\n$ git mv LICESE LICENSE\n$ git commit -m \nFix: Nombre de archivo LICENSE\n\n$ git push\n\n\n\n\n\nAhora s\u00ed, el administrador puede aprobar la fusi\u00f3n y borrar la rama del repositorio. El panel de Github permite aceptar los cambios directamente o informa de como hacer una copia de la rama ofrecida por el usuario para hacer cambios, como puede verse en la siguiente imagen.\n\n\n\n\nUna vez que se han aceptado los cambios, podemos borrar la rama y actualizar nuestro repositorio con los datos del remoto como hicimos antes. \u00bfPor qu\u00e9 actualizar desde el remoto y no desde nuetra rama \nadd-license\n? Pues porque usualmente el administrador puede haber modificado los cambios que le hemos propuesto, o incluso una tercera persona. Recordemos el cariz colaborativo que tiene Github.\n\n\n$ git checkout master\n$ git branch -d add-license\n# Esto borra la rama local\n$ git push origin --delete add-license\n# Esto borra la rama remota. Tambi\u00e9n puede hacerse desde la web.\n\n\n\n\n\nTodo esto es algo complicado...\n\n\nS\u00ed, lo es, al menos al principio. Git tiene una parte muy sencilla que es el uso del repositorio local (\u00f3rdenes tales como add, rm, mv y commit). El siguiente nivel de complejidad lo componen las \u00f3rdenes para trabajar con ramas y fusionarlas (checkout, branch, merge, rebase) y por \u00faltimo, las que trabajan con repositorios remotos (pull, push, fetch, remote). Adem\u00e1s hay otra serie de \u00f3rdenes para tener informaci\u00f3n (diff, log, status) o hacer operaciones de mantenimiento (fsck, gc). Lo importante para no perderse en Git, es seguir la siguiente m\u00e1xima:\n\n\n\n\nNo avanzar al siguiente nivel de complejidad, hasta no haber entendido completamente el anterior.\n\n\n\n\nMuy poco sentido tiene ponernos a crear ramas en github si a\u00fan no entendemos c\u00f3mo se crean localmente y para que deben usarse. En la parte de referencias hay varios manuales en l\u00ednea, incluso tutoriales interactivos. Tambi\u00e9n hay mucha documentaci\u00f3n disponible en Github que suele venir muy bien explicada. En caso de que tengamos un problema que no sepamos resolver, una web muy buena es \nStackOverflow\n. Es una web de preguntas y respuestas para profesionales; es muy dif\u00edcil que se os plantee una duda que no haya sido ya preguntada y respondida en esa web. Eso s\u00ed, el ingl\u00e9s es imprescindible.\n\n\n\u00daltimo paso, documentaci\u00f3n.\n\n\nGithub permite crear documentaci\u00f3n. En primer lugar, generando un archivo llamado README. Tambi\u00e9n permite crear una web propia para el proyecto y, adem\u00e1s, una wiki. Para marcar el texto, se utiliza un lenguaje de marcado de texto denominado \nMarkdown\n. En la siguiente web hay un tutorial interactivo: \nhttp://www.markdowntutorial.com/\n. Como en principio, no es necesario saber Markdown para poder trabajar con Git o con Github, no vamos a incidir m\u00e1s en este asunto.\n\n\nSin embargo, para los curiosos dejamos como referencia la web de \nEasybook\n. Este proyecto, que se encuentra tambi\u00e9n en Github, permite crear documentos en PDF, HTML o ePub a partir de documentos escritos en Markdown. Este manual, por ejemplo, ha sido escrito en Markdown y pasado a PDF con Easybook.", 
            "title": "Github avanzado"
        }, 
        {
            "location": "/github-avanzado/#github-avanzado", 
            "text": "Esta secci\u00f3n trata de c\u00f3mo colaborar con proyectos de terceros.", 
            "title": "Github avanzado"
        }, 
        {
            "location": "/github-avanzado/#clonar-un-repositorio", 
            "text": "Nos vamos a la web del proyecto en el que queremos colaborar. En este caso el proyecto se encuentra en  https://github.com/sgomez/miniblog . Pulsamos en el bot\u00f3n de fork y eso crear\u00e1 una copia en nuestro perfil.   Una vez se termine de clonar el repositorio, nos encontraremos con el espacio de trabajo del mismo:   En la parte superior informaci\u00f3n sobre los commits, ramas, etiquetas, etc.  Justo debajo un explorador de archivos.  En la parte derecha un selector para cambiar de contexto entre: explorador de c\u00f3digo, peticiones de colaboraci\u00f3n (pull request), wiki, configuraci\u00f3n, etc.  Justo abajo a la derecha informaci\u00f3n sobre como clonar localmente o descargar un proyecto.    Github nos permite clonar localmente un proyecto por tres v\u00edas: HTTPS, SSH y Subversion. Seleccionamos SSH y copiamos el texto que despu\u00e9s a\u00f1adiremos a la orden  git clone  como en la primera l\u00ednea del siguiente grupo de \u00f3rdenes:  $ git clone git@github.com:miusuario/miniblog.git\n$ cd miniblog\n$ composer.phar install\n$ php console create-schema  Lo que hace el c\u00f3digo anterior es:   Clona el repositorio localmente  Entramos en la copia  Instalamos las dependencias que la aplicaci\u00f3n tiene  Arrancamos un servidor web para pruebas   Y probamos que nuestra aplicaci\u00f3n funciona:  $ php -S localhost:9999 -t web/  Podemos usar dos direcciones para probarla:   Frontend:  http://localhost:9999/index_dev.php  Backend:  http://localhost:9999/index_dev.php/admin/  con usuario admin y contrase\u00f1a 1234.", 
            "title": "Clonar un repositorio"
        }, 
        {
            "location": "/github-avanzado/#sincronizar-con-el-repositorio-original", 
            "text": "Cuando clonamos un repositorio de otro usuario hacemos una copia del original. Pero esa copia es igual al momento en el que hicimos la copia. Cuando el repositorio original cambie, que lo har\u00e1, nuestro repositorio no se actualizar\u00e1 solo. \u00a1Son dos repositorios diferentes! Necesitamos una manera de poder incorporar los cambios que vaya teniendo el repositorio original en el nuestro. Para eso crearemos una nueva rama remota. Por convenio, y como vimos anteriormente, ya existe una rama remota llamada  origin  que apunta al repositorio de donde clonamos el proyecto, en este caso apunta a nuestro fork en github:  $ git remote show origin\n* remote origin\n  Fetch URL: git@github.com:miusuario/miniblog.git\n  Push  URL: git@github.com:miusuario/miniblog.git\n  HEAD branch (remote HEAD is ambiguous, may be one of the following):\n    develop\n    master\n  Remote branches:\n    develop tracked\n    master  tracked\n  Local branch configured for  git pull :\n    master merges with remote master\n  Local ref configured for  git push :\n    master pushes to master (up to date)  Tambi\u00e9n por convenio, la rama remota que hace referencia al repositorio original se llama  upstream  y se crea de la siguiente manera:  $ git remote add upstream git@github.com:sgomez/miniblog.git\n$ git remote show upstream\n* remote upstream\n  Fetch URL: git@github.com:sgomez/miniblog.git\n  Push  URL: git@github.com:sgomez/miniblog.git\n  HEAD branch: master\n  Remote branches:\n    develop new (next fetch will store in remotes/upstream)\n    master  new (next fetch will store in remotes/upstream)\n  Local ref configured for  git push :\n    master pushes to master (local out of date)  En este caso, la URI debe ser siempre la del proyecto original. Y ahora para incorporar actualizaciones, usaremos el merge en dos pasos:  $ git fetch upstream\n$ git merge upstream/master  Recordemos que  fetch  solo trae los cambios que existan en el repositorio remoto sin hacer ning\u00fan cambio en nuestro repositorio. Es la orden  merge  la que se encarga de que todo est\u00e9 sincronizado. En este caso decimos que queremos fusionar con la rama  master  que est\u00e1 en el repositorio  upstream .", 
            "title": "Sincronizar con el repositorio original"
        }, 
        {
            "location": "/github-avanzado/#creando-nuevas-funcionalidades", 
            "text": "Vamos a crear una nueva funcionalidad: vamos a a\u00f1adir una licencia de uso. Para ello preferentemente crearemos una nueva rama.  $ git checkout -b add-license\n$ echo  LICENCIA MIT    LICESE\n#\u00a0el error es intencionado\n$ git add LICESE\n$ git commit -m  Archivo de licencia de uso   En principio habr\u00eda que probar que todo funciona bien y entonces integraremos en la rama  master  de nuestro repositorio y enviamos los cambios a Github:  $ git checkout master\n$ git merge add-license --no-ff\n$ git branch -d add-license\n# Borramos la rama que ya no nos sirve para nada\n$ git push --set-upstream origin add-license\n# Enviamos la rama a nuestro repositorio origin  Si volvemos a Github, veremos que nos avisa de que hemos subido una nueva rama y si queremos crear un pull request.   Pulsamos y entramos en la petici\u00f3n de  Pull Request . Este es el momento para revisar cualquier error antes de enviar al due\u00f1o del repositorio. Como vemos hemos cometido uno, nombrando el fichero, si lo correguimos debemos hacer otro push para ir actualizando la rama. Cuando est\u00e9 lista volvemos aqu\u00ed y continuamos. Hay que dejar una descripci\u00f3n del cambio que vamos a hacer.   Una vez hemos terminado y nos aseguramos que todo est\u00e1 correcto, pulsamos  Send pull request  y le llegar\u00e1 nuestra petici\u00f3n al due\u00f1o del proyecto.   Sin embargo, para esta prueba, no vamos a cambiar el nombre del archivo y dejaremos el error como est\u00e1. As\u00ed de esta manera al administrador del proyecto le llegar\u00e1 el  Pull Request  y la lista de cambios. Ahora en principio, cabr\u00eda esperar que el administrador aprobara los cambios, pero podr\u00eda pasar que nos indicara que cambiemos algo. En ese caso solo habr\u00eda que modificar la rama y volverla a enviar.  $ git mv LICESE LICENSE\n$ git commit -m  Fix: Nombre de archivo LICENSE \n$ git push  Ahora s\u00ed, el administrador puede aprobar la fusi\u00f3n y borrar la rama del repositorio. El panel de Github permite aceptar los cambios directamente o informa de como hacer una copia de la rama ofrecida por el usuario para hacer cambios, como puede verse en la siguiente imagen.   Una vez que se han aceptado los cambios, podemos borrar la rama y actualizar nuestro repositorio con los datos del remoto como hicimos antes. \u00bfPor qu\u00e9 actualizar desde el remoto y no desde nuetra rama  add-license ? Pues porque usualmente el administrador puede haber modificado los cambios que le hemos propuesto, o incluso una tercera persona. Recordemos el cariz colaborativo que tiene Github.  $ git checkout master\n$ git branch -d add-license\n# Esto borra la rama local\n$ git push origin --delete add-license\n# Esto borra la rama remota. Tambi\u00e9n puede hacerse desde la web.", 
            "title": "Creando nuevas funcionalidades"
        }, 
        {
            "location": "/github-avanzado/#todo-esto-es-algo-complicado", 
            "text": "S\u00ed, lo es, al menos al principio. Git tiene una parte muy sencilla que es el uso del repositorio local (\u00f3rdenes tales como add, rm, mv y commit). El siguiente nivel de complejidad lo componen las \u00f3rdenes para trabajar con ramas y fusionarlas (checkout, branch, merge, rebase) y por \u00faltimo, las que trabajan con repositorios remotos (pull, push, fetch, remote). Adem\u00e1s hay otra serie de \u00f3rdenes para tener informaci\u00f3n (diff, log, status) o hacer operaciones de mantenimiento (fsck, gc). Lo importante para no perderse en Git, es seguir la siguiente m\u00e1xima:   No avanzar al siguiente nivel de complejidad, hasta no haber entendido completamente el anterior.   Muy poco sentido tiene ponernos a crear ramas en github si a\u00fan no entendemos c\u00f3mo se crean localmente y para que deben usarse. En la parte de referencias hay varios manuales en l\u00ednea, incluso tutoriales interactivos. Tambi\u00e9n hay mucha documentaci\u00f3n disponible en Github que suele venir muy bien explicada. En caso de que tengamos un problema que no sepamos resolver, una web muy buena es  StackOverflow . Es una web de preguntas y respuestas para profesionales; es muy dif\u00edcil que se os plantee una duda que no haya sido ya preguntada y respondida en esa web. Eso s\u00ed, el ingl\u00e9s es imprescindible.", 
            "title": "Todo esto es algo complicado..."
        }, 
        {
            "location": "/github-avanzado/#ultimo-paso-documentacion", 
            "text": "Github permite crear documentaci\u00f3n. En primer lugar, generando un archivo llamado README. Tambi\u00e9n permite crear una web propia para el proyecto y, adem\u00e1s, una wiki. Para marcar el texto, se utiliza un lenguaje de marcado de texto denominado  Markdown . En la siguiente web hay un tutorial interactivo:  http://www.markdowntutorial.com/ . Como en principio, no es necesario saber Markdown para poder trabajar con Git o con Github, no vamos a incidir m\u00e1s en este asunto.  Sin embargo, para los curiosos dejamos como referencia la web de  Easybook . Este proyecto, que se encuentra tambi\u00e9n en Github, permite crear documentos en PDF, HTML o ePub a partir de documentos escritos en Markdown. Este manual, por ejemplo, ha sido escrito en Markdown y pasado a PDF con Easybook.", 
            "title": "\u00daltimo paso, documentaci\u00f3n."
        }, 
        {
            "location": "/gitflow/", 
            "text": "Flujo de trabajo con Git (git flow)\n\n\nLa importancia de la organizaci\u00f3n del flujo de trabajo\n\n\nEn la introducci\u00f3n vimos los diferentes esquemas de organizaci\u00f3n externa de los repositorios (es decir, en lo relativo a los usuarios que componen el equipo de trabajo). Pero el repositorio en s\u00ed tambi\u00e9n tiene su esquema de organizaci\u00f3n. En los ejemplos hemos visto que usabamos una rama m\u00e1ster y cre\u00e1bamos ramas para a\u00f1adir funcionalidades que luego integr\u00e1bamos. Es un forma de trabajar de las muchas que hay propuestas, posiblemente la m\u00e1s simple, pero tiene el inconveniente de dejar la rama m\u00e1ster a expensas de una mala actualizaci\u00f3n y quedarnos sin una rama estable. Por eso, hay otras propuestas mejores que permiten separar el trabajo de desarrollo con el mantenimiento de las versiones estables. Una de las m\u00e1s conocidas es la propuesta por \nVincent Driessen\n y que podemos ver en la figura siguiente.\n\n\n\n\nLas ramas principales\n\n\nEn este esquema hay dos ramas principales con un tiempo de vida indefinido:\n\n\n\n\nmaster (\norigin/master\n): el c\u00f3digo apuntado por \nHEAD\n siempre contiene un estado listo para producci\u00f3n.\n\n\ndevelop (\norigin/develop\n): el c\u00f3digo apuntado por \nHEAD\n siempre contiene los \u00faltimos cambios desarrollados para la pr\u00f3xima versi\u00f3n del software. Tambi\u00e9n se le puede llamar \nrama de integraci\u00f3n\n. No es necesariamente estable.\n\n\n\n\nCuando el c\u00f3digo de la rama de desarrollo es lo suficientemente estable, se integra con la rama master y una nueva versi\u00f3n es lanzada.\n\n\nLas ramas auxiliares\n\n\nPara labores concretas, pueden usarse otro tipo de ramas, las cuales tienen un tiempo de vida definido. Es decir, cuando ya no son necesarias se eliminan:\n\n\n\n\nRamas de funcionalidad (feature branches)\n\n\nRamas de versi\u00f3n (release branches)\n\n\nRamas de parches (hotfix branches)\n\n\n\n\nFeature branches\n\n\n\n\nPueden partir de: develop\n\n\nDeben fusionarse con: develop\n\n\nConvenici\u00f3n de nombres: feature-NUMissue-*.\n\n\n\n\nRelease branches\n\n\n\n\nPueden partir de: develop\n\n\nDeben fusionarse con: develop y master\n\n\nConvenici\u00f3n de nombres: release-*\n\n\n\n\nHotfix branches\n\n\n\n\nPueden partir de: master\n\n\nDeben fusionarse con: develop y master\n\n\nConvenici\u00f3n de nombres: hotfix-*\n\n\n\n\nLa extensi\u00f3n flow de Git\n\n\nUna de las ventajas de Git es que, adem\u00e1s, es extensible. Es decir, se pueden crear nuevas \u00f3rdenes como si de plugins se tratara. Una de las m\u00e1s usadas es \ngitflow\n, que est\u00e1 basada en el art\u00edculo que hablamos al principio de este cap\u00edtulo.\n\n\nInstalaci\u00f3n\n\n\nAunque la fuente original de la extensi\u00f3n es del mismo autor del art\u00edculo, el c\u00f3digo no se encuentra ya muy actualizado y hay un fork bastante m\u00e1s activo en \npetervanderdoes/gitflow\n. En el wiki del repositorio est\u00e1n las \ninstrucciones de instalaci\u00f3n\n para distintos sistemas. Una vez instalados tendremos una nueva \u00f3rden: \ngit flow\n.\n\n\nUso\n\n\nPara cambiar a las ramas master y develop, seguiremos usando  \ngit checkout\n, pero para trabajar con las ramas antes indicadas gitflow nos facilita las siguientes \u00f3rdenes:\n\n\n\n\ngit flow init\n: Permite inicializar el espacio de trabajo.\n\n\ngit flow feature\n: Permite crear y trabajar con ramas de funcionalidades.\n\n\ngit flow release\n: Permite crear y trabajar con ramas de versiones.\n\n\ngit flow hotfix\n: Permite crear y trabajar con ramas de parches.\n\n\n\n\nEn el siguiente cap\u00edtulo veremos como usarlas para trabajar en un proyecto ya creado.", 
            "title": "Flujo de trabajo con Git (git flow)"
        }, 
        {
            "location": "/gitflow/#flujo-de-trabajo-con-git-git-flow", 
            "text": "", 
            "title": "Flujo de trabajo con Git (git flow)"
        }, 
        {
            "location": "/gitflow/#la-importancia-de-la-organizacion-del-flujo-de-trabajo", 
            "text": "En la introducci\u00f3n vimos los diferentes esquemas de organizaci\u00f3n externa de los repositorios (es decir, en lo relativo a los usuarios que componen el equipo de trabajo). Pero el repositorio en s\u00ed tambi\u00e9n tiene su esquema de organizaci\u00f3n. En los ejemplos hemos visto que usabamos una rama m\u00e1ster y cre\u00e1bamos ramas para a\u00f1adir funcionalidades que luego integr\u00e1bamos. Es un forma de trabajar de las muchas que hay propuestas, posiblemente la m\u00e1s simple, pero tiene el inconveniente de dejar la rama m\u00e1ster a expensas de una mala actualizaci\u00f3n y quedarnos sin una rama estable. Por eso, hay otras propuestas mejores que permiten separar el trabajo de desarrollo con el mantenimiento de las versiones estables. Una de las m\u00e1s conocidas es la propuesta por  Vincent Driessen  y que podemos ver en la figura siguiente.", 
            "title": "La importancia de la organizaci\u00f3n del flujo de trabajo"
        }, 
        {
            "location": "/gitflow/#las-ramas-principales", 
            "text": "En este esquema hay dos ramas principales con un tiempo de vida indefinido:   master ( origin/master ): el c\u00f3digo apuntado por  HEAD  siempre contiene un estado listo para producci\u00f3n.  develop ( origin/develop ): el c\u00f3digo apuntado por  HEAD  siempre contiene los \u00faltimos cambios desarrollados para la pr\u00f3xima versi\u00f3n del software. Tambi\u00e9n se le puede llamar  rama de integraci\u00f3n . No es necesariamente estable.   Cuando el c\u00f3digo de la rama de desarrollo es lo suficientemente estable, se integra con la rama master y una nueva versi\u00f3n es lanzada.", 
            "title": "Las ramas principales"
        }, 
        {
            "location": "/gitflow/#las-ramas-auxiliares", 
            "text": "Para labores concretas, pueden usarse otro tipo de ramas, las cuales tienen un tiempo de vida definido. Es decir, cuando ya no son necesarias se eliminan:   Ramas de funcionalidad (feature branches)  Ramas de versi\u00f3n (release branches)  Ramas de parches (hotfix branches)", 
            "title": "Las ramas auxiliares"
        }, 
        {
            "location": "/gitflow/#feature-branches", 
            "text": "Pueden partir de: develop  Deben fusionarse con: develop  Convenici\u00f3n de nombres: feature-NUMissue-*.", 
            "title": "Feature branches"
        }, 
        {
            "location": "/gitflow/#release-branches", 
            "text": "Pueden partir de: develop  Deben fusionarse con: develop y master  Convenici\u00f3n de nombres: release-*", 
            "title": "Release branches"
        }, 
        {
            "location": "/gitflow/#hotfix-branches", 
            "text": "Pueden partir de: master  Deben fusionarse con: develop y master  Convenici\u00f3n de nombres: hotfix-*", 
            "title": "Hotfix branches"
        }, 
        {
            "location": "/gitflow/#la-extension-flow-de-git", 
            "text": "Una de las ventajas de Git es que, adem\u00e1s, es extensible. Es decir, se pueden crear nuevas \u00f3rdenes como si de plugins se tratara. Una de las m\u00e1s usadas es  gitflow , que est\u00e1 basada en el art\u00edculo que hablamos al principio de este cap\u00edtulo.", 
            "title": "La extensi\u00f3n flow de Git"
        }, 
        {
            "location": "/gitflow/#instalacion", 
            "text": "Aunque la fuente original de la extensi\u00f3n es del mismo autor del art\u00edculo, el c\u00f3digo no se encuentra ya muy actualizado y hay un fork bastante m\u00e1s activo en  petervanderdoes/gitflow . En el wiki del repositorio est\u00e1n las  instrucciones de instalaci\u00f3n  para distintos sistemas. Una vez instalados tendremos una nueva \u00f3rden:  git flow .", 
            "title": "Instalaci\u00f3n"
        }, 
        {
            "location": "/gitflow/#uso", 
            "text": "Para cambiar a las ramas master y develop, seguiremos usando   git checkout , pero para trabajar con las ramas antes indicadas gitflow nos facilita las siguientes \u00f3rdenes:   git flow init : Permite inicializar el espacio de trabajo.  git flow feature : Permite crear y trabajar con ramas de funcionalidades.  git flow release : Permite crear y trabajar con ramas de versiones.  git flow hotfix : Permite crear y trabajar con ramas de parches.   En el siguiente cap\u00edtulo veremos como usarlas para trabajar en un proyecto ya creado.", 
            "title": "Uso"
        }, 
        {
            "location": "/referencias/", 
            "text": "Referencias\n\n\n\n\nDocumentaci\u00f3n oficial en ingl\u00e9s\n.\n\n\nDocumentaci\u00f3n oficial en espa\u00f1ol (quiz\u00e1s incompleta)\n.\n\n\nCurso de Git (ingl\u00e9s)\n. La mayor\u00eda de la documentaci\u00f3n de este manual est\u00e1 basada en este curso.\n\n\nCurso interactivo de Git (ingl\u00e9s)\n.\n\n\nP\u00e1gina de referencia de todas las \u00f3rdenes de Git (ingl\u00e9s)\n.\n\n\nChuleta con las \u00f3rdenes m\u00e1s usuales de Git\n.\n\n\nGitmagic (ingles y espa\u00f1ol). Otro manual de Git\n\n\nArt\u00edculo t\u00e9cnico: Un modelo exitoso de ramificaci\u00f3n en Git \n.\n\n\nCurso detallado y gratuito sobre Git y github\n\n\nOtra guia r\u00e1pida de git\n\n\nGu\u00eda de estilos seg\u00fan Udacity", 
            "title": "Referencias"
        }, 
        {
            "location": "/referencias/#referencias", 
            "text": "Documentaci\u00f3n oficial en ingl\u00e9s .  Documentaci\u00f3n oficial en espa\u00f1ol (quiz\u00e1s incompleta) .  Curso de Git (ingl\u00e9s) . La mayor\u00eda de la documentaci\u00f3n de este manual est\u00e1 basada en este curso.  Curso interactivo de Git (ingl\u00e9s) .  P\u00e1gina de referencia de todas las \u00f3rdenes de Git (ingl\u00e9s) .  Chuleta con las \u00f3rdenes m\u00e1s usuales de Git .  Gitmagic (ingles y espa\u00f1ol). Otro manual de Git  Art\u00edculo t\u00e9cnico: Un modelo exitoso de ramificaci\u00f3n en Git  .  Curso detallado y gratuito sobre Git y github  Otra guia r\u00e1pida de git  Gu\u00eda de estilos seg\u00fan Udacity", 
            "title": "Referencias"
        }
    ]
}